---
title: "Triaging PowerShell Exploitation with Rekall"
date: 2015-09-18T00:12:00.002-04:00
draft: false
type: posts
categories: 
- 
---
# Triaging PowerShell Exploitation with Rekall

<br/>

<br/>
David recently published his article [Spotting the Adversary](http://www.redblue.team/2015/09/spotting-adversary-with-windows-event.html) so I figured I'd continue the trend and focus on Blue Team tactics in this post.  
  
I've spent a fair bit of time in EnCase. They have a great product and a number of solutions to fit most of your needs, but at times it can feel bulky and a little stiff. Moreover, it has an arguably non-intuitive user interface and is an expensive solution that a lot of organizations cannot afford. Volatility is fantastic but for this post I wanted to focus specifically on Rekall. Incident Response and Forensics require a superb understanding of operating system internals, file system structures, and malware behavior patterns, but tools like Volatility and Rekall greatly reduce the barrier to entry for security analysts and service providers.  
  
[Rekall](http://www.rekall-forensic.com/) is a complete end to end memory forensics framework (branched from [Volatility](https://github.com/volatilityfoundation) itself). The developers of this project wanted to focus on improving modularity, usability, and performance. One of the most significant advantages to using Rekall is that at allows for local or remote _live_ forensic analysis. For this reason it is a core component of the [Google Rapid Response](https://github.com/google/grr) tool.  
  
In this article I wanted to document a common offensive tactic and then briefly step through some investigatory steps. This is by no means a complete incident response process, and the scenario assumes the attacker has some level of access to the system or network already.  
  
**Red Team**  
I am a big fan of Matt Graeber's [PowerSploit](https://github.com/mattifestation/PowerSploit). PowerSploit is essentially a set of PowerShell scripts designed to aid penetration testers during all phases of an assessment. You can use it to inject DLLs, reflectively load PE files, insert shellcode, bypass anti-virus, load Mimikatz and do all sorts of other wonderful and nefarious things. PowerShell has become extremely popular as an attack vector in the last two years as it is a native trusted process, lacks comprehensive security mechanisms (excluding perhaps the most recent versions), and is an extremely powerful scripting language (direct API support for Windows internals).  
  
In our scenario we assume that the attacker has a limited shell and wants to gain more significant access. First let's set up our listener:  

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjTUm5oKx85SkAwh7inVEznvsggwOM2xYD6x_dvKzqJyY3ZeEjnKkqzos1ByvcX5EImmEyG6-a7ONlHHWgazxRNWpqG1afvPaelgIP6aFhfe2e8dUi6YHjEJ3hTuwe8xxt90LMopHcrJz8/s400/msflistener.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjTUm5oKx85SkAwh7inVEznvsggwOM2xYD6x_dvKzqJyY3ZeEjnKkqzos1ByvcX5EImmEyG6-a7ONlHHWgazxRNWpqG1afvPaelgIP6aFhfe2e8dUi6YHjEJ3hTuwe8xxt90LMopHcrJz8/s1600/msflistener.PNG)

I've elected to use the Reverse\_HTTPS Meterpreter payload as the PowerSploit Invoke-Shellcode script used later on only supports the Reverse\_HTTPS and Reverse\_HTTP variants (and as such it is preferable to pass this traffic over SSL).  
  
On the compromised machine we will now execute a PowerShell one-liner to retrieve the Invoke-Shellcode PS1 script from the PowerSploit GitHub page. This is a nice method of retrieval as GitHub is not a suspicious or inherently untrustworthy page and the request is submitted over HTTPS (which can help with evasion at the URL filtering/web traffic content inspection layers). Additional levels of evasion can be employed by encrypting our PS1 script but I'm not going to explore that option for the purposes of this demo.  

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh_iWjzH2M0C_BVTJXCO_3T2B2vcN3YCV7dyt_WSPAGmnvV0DIHoYBvXU0FLBpDo0N7sunM8NyikvqlYwSIkM2LOI3f-gjwzKmvKr9AXAxjIOBgLGiLOOqhg9yKAMkpuqPYnIhWF7grBds/s400/powershell+cradle.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh_iWjzH2M0C_BVTJXCO_3T2B2vcN3YCV7dyt_WSPAGmnvV0DIHoYBvXU0FLBpDo0N7sunM8NyikvqlYwSIkM2LOI3f-gjwzKmvKr9AXAxjIOBgLGiLOOqhg9yKAMkpuqPYnIhWF7grBds/s1600/powershell+cradle.PNG)

What's happening here? PowerShell is calling IEX (Invoke-Expression) to generate a new WebClient object and calls the DownloadString function to retrieve the URL. The Invoke-Shellcode script is executed with the switches that will instantiate a connection to our MSF listener. This is all executed in the context of the PowerShell process itself.

  

In Metasploit we see a session is established and migrate processes. In this example I am migrating to Notepad. This is not good trade-craft and I'm only doing this to make things more discernible and easy to grasp forensically in the next section.

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiawm1BfOSKeNdMqpvHQybjlrB2ga8ZnIyhdp5opDA0Ua8ZCBp5wZY0drkLWv8E6AUoDv-uwkfZEVxkRDM89cKz_4vHYLECKefltK4md5QEsABvDsll-FtXaxBhP4V74_1paxlpDs9ikk0/s400/reverse+shell+established.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiawm1BfOSKeNdMqpvHQybjlrB2ga8ZnIyhdp5opDA0Ua8ZCBp5wZY0drkLWv8E6AUoDv-uwkfZEVxkRDM89cKz_4vHYLECKefltK4md5QEsABvDsll-FtXaxBhP4V74_1paxlpDs9ikk0/s1600/reverse+shell+established.PNG)

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhM2f7Bs4YTk-OI6mPC-OFuhdfpDLlqNyUAdTA5SvZEJbTfOsjR0VVr5HVTcqOzfz9JtJ8QsJuQy5B6OdraV3WxdCy5VG87S8WKbPPxwk-bs8V94hK4nKA89SE2e9LsmCae39cLzB49ZA8/s400/migrate.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhM2f7Bs4YTk-OI6mPC-OFuhdfpDLlqNyUAdTA5SvZEJbTfOsjR0VVr5HVTcqOzfz9JtJ8QsJuQy5B6OdraV3WxdCy5VG87S8WKbPPxwk-bs8V94hK4nKA89SE2e9LsmCae39cLzB49ZA8/s1600/migrate.PNG)

At this point we can start looking at things from the other perspective.

  

**Blue Team**

First let's drop WinPMem on the system. WinPMem is a kernel mode driver that allows us to gain access to physical memory and map it is a device. 

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjXylWr1vmRzMH5CRKGBAo7mALL2vVb9-sW5aGUSVJ3n27eEqiUjoN61jSm1sV0h_Pmlaf9r4iwP1vHA85gvb8hesrSXnmn7mMuMiztivHcChly7b6vfgwI5O7-Ki9JIi-bf0yvhYTwihw/s400/winpmem.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjXylWr1vmRzMH5CRKGBAo7mALL2vVb9-sW5aGUSVJ3n27eEqiUjoN61jSm1sV0h_Pmlaf9r4iwP1vHA85gvb8hesrSXnmn7mMuMiztivHcChly7b6vfgwI5O7-Ki9JIi-bf0yvhYTwihw/s1600/winpmem.PNG)

Once this is done we can use Rekall to perform live memory forensics on the system. Navigate to your Rekall install directory and run the following command to mount the WinPMem device:

> _rekall.exe -f \\\\.\\pmem_

This will launch a Rekall interactive console.  Rekall has support for a lot of native plugins (that you are likely familiar with if you have ever used Volatility). Typing plugins. \[tab\] \[tab\] will print a list of options. To get additional information type plugins.\[pluginname\]? Many plugins also have switches that allow you to filter your query based on a specified criteria. To see the list of available switches type pluginname \[tab\].

  

A good starting point is the _netscan_ plugin. 

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi0GYtffcBtG0DTt-FxZBPu0Oqclnhmu-lQWN70AfFDT-vD9s9roAJpRmrytCxACS3r58Jj3VItnoy9Qnbmw2XzJXjDqtLNX7Yp6RRLkmitMX9M0zwwbwK3BwzNMTZi1i_NeWRJ0fwo5zU/s400/start+netscan.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi0GYtffcBtG0DTt-FxZBPu0Oqclnhmu-lQWN70AfFDT-vD9s9roAJpRmrytCxACS3r58Jj3VItnoy9Qnbmw2XzJXjDqtLNX7Yp6RRLkmitMX9M0zwwbwK3BwzNMTZi1i_NeWRJ0fwo5zU/s1600/start+netscan.PNG)

You should also run pslist when starting your analysis to understand what processes are running. Nothing out of the ordinary but as we continue to browse we see Notepad has a network socket established:

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjC0HWXMpjpkAIs89Phxi-by937T51PxC_qlyh-cm6wwhZdB4QZgkVEL9JWhAtqq9xs7QKZj_v1gOv-5Y6Ua1qSbLypGnoqtNUMm4ZEswgSvBmH3vEEVX4nDO1hF2NAHVhyPon5UXjKkMw/s320/notepad+beacon.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjC0HWXMpjpkAIs89Phxi-by937T51PxC_qlyh-cm6wwhZdB4QZgkVEL9JWhAtqq9xs7QKZj_v1gOv-5Y6Ua1qSbLypGnoqtNUMm4ZEswgSvBmH3vEEVX4nDO1hF2NAHVhyPon5UXjKkMw/s1600/notepad+beacon.PNG)

It is clear that this process has been hooked as Notepad should never establish network connections. Let's use the LDRModules plugin to detect unlinked DLLs.

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhQhLj8RhSBkDMwFYOrVgN_8Lsny2SDxz6NtKFjrC0tII-tK5B0HgKeiRja5-4WL2vW8W32V7-05XgEyEtmDJk7-fyh_gEM5jn9OqCKTy8uYJqWUclm1Xyg9QoN9QEQQ7tmPJlHZyY6YZg/s400/unlinked+dlls.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhQhLj8RhSBkDMwFYOrVgN_8Lsny2SDxz6NtKFjrC0tII-tK5B0HgKeiRja5-4WL2vW8W32V7-05XgEyEtmDJk7-fyh_gEM5jn9OqCKTy8uYJqWUclm1Xyg9QoN9QEQQ7tmPJlHZyY6YZg/s1600/unlinked+dlls.PNG)

We see a list of unlinked DLLs and some that stand out as extremely suspicious. So we know that Notepad was injected into by a different process (or spawned by malware using a technique known as process hollowing). Obviously for this example we know that Meterpreter migrated to this process.

  

Meterpreter has a fairly standard migration process:

1.  Identify the PID.
2.  Scan for architecture of target process.
3.  Check if the SeDebugPrivilege is set to get handle to target process.
4.  Calculate payload length.
5.  Call OpenProcess() to gain access to Virtual Memory of target process.
6.  Call VirtualAllocEx() to assign PAGE\_EXECUTE\_READWRITE.
7.  Call WriteProcessMemory() to write the payload into the target process allocated memory region.
8.  Call CreateRemoteThread() to execute the payload.
9.  Close the prior thread from the old Meterpreter session.

In knowing this we look for additional suspect processes. I like to look for cmd.exe or powershell.exe and dump these processes memory regions for string analysis. When I ran pslist earlier I identified a PowerShell process and ran the memdump pid=\[PowerShellPID\] plugin. This will produce a DMP file that you can load in your favorite editor.  

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjG1HqWCNAOxc7x6si1dG4hlEUoY4KO2BsMaASZGK8tMiLVjEpa44WVvr2o_hyphenhypheng2-pvgxrAHGST-eXddOKUTSApwnC3W10FKPHrq_lcUjUChQBTptfHELCo2JR4G5Fn3RH9heUPs4LWtAM/s400/powershell+process+dump.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjG1HqWCNAOxc7x6si1dG4hlEUoY4KO2BsMaASZGK8tMiLVjEpa44WVvr2o_hyphenhypheng2-pvgxrAHGST-eXddOKUTSApwnC3W10FKPHrq_lcUjUChQBTptfHELCo2JR4G5Fn3RH9heUPs4LWtAM/s1600/powershell+process+dump.PNG)

I was able to find suspicious strings by searching for keywords such as 'IEX', 'Download', and other commands that might be used by an attacker. At this point I am able to extract the full PowerSploit script from memory and have identified that my attacker downloaded a Meterpreter stager. From an Incident Response perspective we have numerous Indicators of Compromise to work with.  
  
Lastly, ProcExplorer from Mark Russinovich is a great tool for at a glance identification of suspect activity. Let's look at spawned threads and stack information from a normal Notepad process relative to a hooked one:  

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg7qzC4oct4nnsVHYGXT9rjtWyejuG6lkF-eg8_L9fGwTwRBr75ktqEOxOMTuljbMYOjTNj0-5F2vU9RGKXTNvjVtLUT4j3EAZ4bNaGvIVUP8wGX8xutqoUtt9eK1-oTbuiGBSiBZx3_pc/s320/notepad+process.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg7qzC4oct4nnsVHYGXT9rjtWyejuG6lkF-eg8_L9fGwTwRBr75ktqEOxOMTuljbMYOjTNj0-5F2vU9RGKXTNvjVtLUT4j3EAZ4bNaGvIVUP8wGX8xutqoUtt9eK1-oTbuiGBSiBZx3_pc/s1600/notepad+process.PNG)

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhhH1-9T_eT3bANrBA380IreIWzBRN9pUYYBpLwYHsNSKVI3qH9a80udgYmbV-PFsE0txZwuGu8kBQWFZjpNTrsfD0y8I8rfhX4FjqKu7a5IouNIeXd5yxBSOrqjl2NyBSIDcF4vTK-WY4/s320/additionalnotepadthreads.PNG)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhhH1-9T_eT3bANrBA380IreIWzBRN9pUYYBpLwYHsNSKVI3qH9a80udgYmbV-PFsE0txZwuGu8kBQWFZjpNTrsfD0y8I8rfhX4FjqKu7a5IouNIeXd5yxBSOrqjl2NyBSIDcF4vTK-WY4/s1600/additionalnotepadthreads.PNG)

This is by no means a complex attack and there is much more we can do from a memory analysis perspective, but I think the material covered serves as a gentle introduction to the topic. I'll likely follow up on this post in the future and go into more depth but hopefully this information is enough to get you started.  
  
There are a number of fantastic writers covering these types of topics in the blogosphere and I wanted to link to them here as they are all doing amazing work. I came across some great posts while doing research:  
http://holisticinfosec.blogspot.ca/2015/05/toolsmith-attack-detection-hunting-in.html  
http://www.tekdefense.com/news/2013/12/23/analyzing-darkcomet-in-memory.html  
http://www.behindthefirewalls.com/2013/07/zeus-trojan-memory-forensics-with.html  
https://github.com/volatilityfoundation  
http://www.rekall-forensic.com/  
https://github.com/google/grr  
https://github.com/google/rekall/releases/tag/v1.3.2

#### [Source](https://www.redblue.team/feeds/5175046893973570049/comments/default)

<br/>
---
